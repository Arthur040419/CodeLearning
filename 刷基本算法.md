# 基本算法

这篇笔记用于记录我基本算法的学习。

参考资料：[代码随想录](https://programmercarl.com/)

# 数组

## 1.二分查找

### 题目

LeetCode原题：[704. 二分查找 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-search/description/)

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

示例 1:

```text
输入: nums = [-1,0,3,5,9,12], target = 9     
输出: 4       
解释: 9 出现在 nums 中并且下标为 4     
```

示例 2:

```text
输入: nums = [-1,0,3,5,9,12], target = 2     
输出: -1        
解释: 2 不存在 nums 中因此返回 -1        
```

提示：

- 你可以假设 nums 中的所有元素是不重复的。
- n 将在 [1, 10000]之间。
- nums 的每个元素都将在 [-9999, 9999]之间。



### 思路

仅仅是一道简单的二分查找我也收获了很多。

我虽然能够把这题写出来，但是我没有一个完整的思路，属于是想到哪写到哪，这种写代码的方式很容易导致细节方面的错误，而且写的代码质量也不咋地，说实话，看起来杂乱无章。

我的代码

```java
public static int search(int[] nums, int target) {
    if(target<nums[0]||target>nums[nums.length-1]){
        //避免目标不不在数组内的时候还仍然跑到数组里去找
        return -1;
    }
    int left = 0;
    int right = nums.length - 1;
    int mid = (left + right) / 2;
    int rs = -1;
    //如果左边索引已经超过右边索引就退出循环
    while (left <= right) {
        if (nums[mid] == target) {
            rs = mid;
            break;
        } else {
            if (nums[mid] < target) {
                //说明目标值在右半部分
                left = mid + 1;
            } else {
                //说明目标值在左半部分
                right = mid - 1;
            }
        }
        mid = (left + right) / 2;
    }
    return rs;
}
```



一道简单的二分查找的思路也非常耐人寻味。因为说实话，确实如这个代码随想录这个教程所说，我在编写二分查找算法的时候经常会纠结于循环条件到底是`left<=right`,还是`left<right`，实际上这两种都对，只不过对应了两种不同的思路

思路一：

判断区间是[left,right]也就是左闭右闭，就是说判断值在在不在区间内会把两个边界值也考虑进去，这个时候我们在更改指针的时候应该这样做：当`target<nums[mid]`时，应该`right=mid-1`,当`target>nums[mid]`时，应该`left=mid+1`，并且循环条件应该是`left<=right`



思路二：

判断区间是[left,right)也就是左闭右开，也就是说判断时不会把最右边的值考虑进去，这个时候应该这样做：当`target<nums[mid]`时，应该`right=mid`，不用-1，因为判断时不会把最右边的包括进去。当`target>nums[mid]`时，应该`left=mid+1`，因为左边还是包含的，因此得加1。并且此时循环条件应该是`left<right`，因为等于的话就没有意义，反正最右边的值不会算入到判断中。





## 2.移出元素（相向双指针）

### 题目

[27. 移除元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-element/description/)

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并**原地**修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。

示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。

**你不需要考虑数组中超出新长度后面的元素。**



### 思路

这道题我一开始想到的思路是相向双指针，但是写的时候也是依托，代码思路一点也不清晰，乱糟糟的，最后调试半天才过。

通过这道题，我重新学习了相向双指针的代码到底该如何写，真的，不看看这些大佬们的代码，真不知道自己写的代码真就是依托又依托

相向双指针思路

```java
public static int removeElement_My(int[] nums, int val) {
    //相向双指针
    int left = 0;
    int right = nums.length-1;
    while (right >= 0 && nums[right] == val) right--;       //从右往左找到第一个非val值
    while (left <= right) {
        if (nums[left] == val) {
            nums[left] = nums[right];
            right--;
            //如果是我，我会在这里写个count++，完全不会去想用left指针作为返回值
            //count++
        }
        left++;
        while (right >= 0 && nums[right] == val) right--;
    }
    //直接将索引作为返回值，不像我还得拿个什么count变量来记录
    return left;
}
```



除了重新认识了相向双指针外，还学会了快慢指针思路

```
快慢指针思路：
快慢指针同时出发
如果快指针所在位置的值与目标值不同，就交换快慢指针的值，并将快慢指针同时向前移动
如果快指针所在位置的值与目标值相同，就只移动快指针，慢指针不动
```

```java
public static int removeElement(int[] nums, int val) {
    //学到的思路，快慢指针
    int slowIndex = 0;
    for (int fastIndex = 0; fastIndex < nums.length; fastIndex++) {
        if (nums[fastIndex] != val) {
            nums[slowIndex] = nums[fastIndex];
            slowIndex++;
        }
    }
    return slowIndex;
}
```



## 3.有序数组的平方（相向双指针）

### 题目

[力扣题目链接](https://leetcode.cn/problems/squares-of-a-sorted-array/)

给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。

示例 1：

- 输入：nums = [-4,-1,0,3,10]
- 输出：[0,1,9,16,100]
- 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]

示例 2：

- 输入：nums = [-7,-3,2,3,11]
- 输出：[4,9,9,49,121]



### 思路

这题还是双指针，数组实际上是排好序的，只不过在平方后，前面的可能会比后面的大，所以可以分别用指针来指最前面和最后面，因为平方后的最大值一定是首尾两个中的一个

```java
public static int[] sortedSquares(int[] nums) {
    //相向双指针
    int left = 0;
    int right = nums.length - 1;
    int[] newArr = new int[nums.length];
    //逆向放入新数组，因为平方后最大值一定在最两边
    for (int i = newArr.length - 1; i >= 0; i--) {
        if((nums[left]*nums[left])>(nums[right]*nums[right])){
            newArr[i]=nums[left]*nums[left];
            left++;
        }else{
            newArr[i]=nums[right]*nums[right];
            right--;
        }
    }
    return newArr;
}
```





## 4.长度最小的子数组（滑动窗口）

### 题目

[力扣题目链接](https://leetcode.cn/problems/minimum-size-subarray-sum/)

给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。

示例：

- 输入：s = 7, nums = [2,3,1,2,4,3]
- 输出：2
- 解释：子数组 [4,3] 是该条件下的长度最小的子数组。

提示：

- 1 <= target <= 10^9
- 1 <= nums.length <= 10^5
- 1 <= nums[i] <= 10^5



### 思路

滑动窗口：**就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果**。

这题的思路是滑动窗口，这里窗口指的就是子数组，滑动窗口指的就是动态改变子数组的长度，那这个动态是怎么个动态法？

如果当前子数组的和小于目标值，就扩大窗口，也就是向后移动移动右边的指针，并保持左边的指针不动

如果当前子数组的和小于目标值，就缩小窗口，也就是向后移动左边的指针，并保持右边的指针不动，直到子数组的和小于目标值。

这样就能一步步找到最短的子数组，就像试探一样，先一直加加加，当加到超过目标值后就尝试慢慢减，看到底减多少会刚好小于目标值

代码如下

```java
public static int minSubArrayLen(int target, int[] nums) {
    //思路：滑动窗口
    int rs = Integer.MAX_VALUE;
    //滑动窗口前面的指针
    int fast = 0;
    //滑动窗口后面的指针
    int slow = 0;
    //子数组的和
    int sum = 0;
    for (fast = 0; fast < nums.length; fast++) {
        sum += nums[fast];
        while (sum >= target) {
            int subLength = fast - slow + 1;
            rs = rs < subLength ? rs : subLength;
            sum-=nums[slow++];
        }
    }
    if(rs==Integer.MAX_VALUE) return 0;
    return rs;
}
```







## 5.螺旋矩阵II

### 题目

[力扣题目链接](https://leetcode.cn/problems/spiral-matrix-ii/)

给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。

示例:

输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]



### 思路

这题没有涉及到算法，主要是要掌握螺旋矩阵的模拟过程。这个模拟过程看似思路侵袭，实则处处碰壁。

我自己写代码的时候就有下面这些问题：

1.当n为1的特殊情况没有处理

2.无法正确把握下一次要填数据的位置



实际上就算是模拟也讲究思路的，这题主要要抓住一个循环不变量原则，这里的不变量指的是在分别处理上行、右列、下行、左列时到底是左闭右闭还是左闭右开还是其他，这里的话个人感觉左闭右开会好写很多，也就是在处理的时候每行，每列的最后一个不处理。

然后这题还有个技巧，就是每处理完一轮上行、右列、下行、左列可以看成是处理完一圈，也就是说可以按每圈每圈来处理，只不过这个圈每次都会逐渐变小，例如如果n为4，就有两圈，最外面一圈是边长为4的正方形，里面一圈是边长为2的正方形，如果n为3，最外面一圈就是边长为3的正方形，最里面是边长为1的正方形，也就是一个点。

所以我们可以得到一个结论，n阶矩阵可以看成n/2(向下取整)个正方形嵌套而成，其中如果n为奇数的时候还要在此基础上加上一个点，也就是1阶矩阵，这个要单独处理

仿照示例代码，并做出了点修改

```java
public static int[][] generateMatrix(int n) {
    //仿示例代码
    int[][] arr = new int[n][n];
    //每次要放入的数据
    int value = 1;
    //代表行
    int row = 0;
    //代表列
    int column = 0;
    //代表圈的边长,每圈的边长等于n-（循环圈数-1）*2
    int side = n;
    //代表循环的圈数
    int loop = 1;
    while (loop <= n / 2) {
        //处理上行
        for (int i = 0; i < side - 1; i++) {
            arr[row][column++] = value++;
        }
        //处理右列
        for (int i = 0; i < side - 1; i++) {
            arr[row++][column] = value++;
        }
        //处理下行
        for (int i = 0; i < side - 1; i++) {
            arr[row][column--] = value++;
        }
        //处理左列
        for (int i = 0; i < side - 1; i++) {
            arr[row--][column] = value++;
        }
        //处理完一圈，圈数加1
        loop++;
        //边长减2
        side -= 2;
        //重设每圈的起点
        row = loop - 1;
        column = loop - 1;
    }
    //对n为奇数时单独处理
    if (n % 2 == 1) {
        arr[row][column]=n*n;
    }
    return arr;

}
```



## 6.区间和（方法:前缀和）

### 题目

[题目链接](https://kamacoder.com/problempage.php?pid=1070)

题目描述

给定一个整数数组 Array，请计算该数组在每个指定区间内元素的总和。

输入描述

第一行输入为整数数组 Array 的长度 n，接下来 n 行，每行一个整数，表示数组的元素。随后的输入为需要计算总和的区间，直至文件结束。

输出描述

输出每个指定区间内元素的总和。

输入示例

```text
5
1
2
3
4
5
0 1
1 3
```

输出示例

```text
3
9
```

数据范围：

0 < n <= 100000



### 思路

最容易想到的就是暴力求解，直接先输入数组，在遍历数组取区间和。但是老是用这种暴力解法是没有办法进步的，暴力解法谁都能想到

这题要用的新思路是：前缀和。前缀和的思想是重复利用计算过的子数组之和，从而降低区间查询的次数。

在输入原数组的时候，就可以创建一个前缀和数组p[]来一步一步记录前缀和，p[i]代表的就是前i个元素的和，最终当数组输入完毕后，前缀和数组也就记录完毕。此时如果我们想要计算某个区间的和，例如计算a、b区间的和，只需要用前缀和p[b]减去前缀和p[a-1]，这里要注意的就是减的时候应该是减p[a-1]而不是p[a]，因为a、b区间的和包括a这个位置的元素。这样做，在每次计算区间和的时候就只用计算一次，不需要像暴力解法那样去重复查找原数组。

代码如下

```java
public static void subArrSum() {
    //前缀和
    Scanner sc = new Scanner(System.in);
    int n = sc.nextInt();
    //前缀和数组，p[i]表示arr[0]~arr[i]的和
    int[] p = new int[n];
    //初始化数组
    p[0] = sc.nextInt();
    for (int i = 1; i < n; i++) {
        int num = sc.nextInt();
        p[i] = p[i - 1] + num;
    }
    int a;
    int b;
    //这里循环条件注意别用true，用sc.hasNext这些
    while(sc.hasNextInt()){
        //输入区间
        a=sc.nextInt();
        b=sc.nextInt();
        if(a==0){
            //对左边界为0的时候特殊处理
            System.out.println(p[b]);
        }else {
            System.out.println(p[b] - p[a - 1]);
        }
    }
    sc.close();

}
```





## 7.开发商购买土地

### 题目

[题目链接](https://kamacoder.com/problempage.php?pid=1044)

【题目描述】

在一个城市区域内，被划分成了n * m个连续的区块，每个区块都拥有不同的权值，代表着其土地价值。目前，有两家开发公司，A 公司和 B 公司，希望购买这个城市区域的土地。

现在，需要将这个城市区域的所有区块分配给 A 公司和 B 公司。

然而，由于城市规划的限制，只允许将区域按横向或纵向划分成两个子区域，而且每个子区域都必须包含一个或多个区块。

为了确保公平竞争，你需要找到一种分配方式，使得 A 公司和 B 公司各自的子区域内的土地总价值之差最小。

注意：区块不可再分。

【输入描述】

第一行输入两个正整数，代表 n 和 m。

接下来的 n 行，每行输出 m 个正整数。

输出描述

请输出一个整数，代表两个子区域内土地总价值之间的最小差距。

【输入示例】

3 3 1 2 3 2 1 3 1 2 3

【输出示例】

0

【提示信息】

如果将区域按照如下方式划分：

1 2 | 3 2 1 | 3 1 2 | 3

两个子区域内土地总价值之间的最小差距可以达到 0。

【数据范围】：

- 1 <= n, m <= 100；
- n 和 m 不同时为 1。

![image-20250308235348389](./pictures/image-20250308235348389.png)



### 思路

还好这题只要求横向划分和纵向划分，如果来个斜向划分就麻烦了。

横向划分，可以看成是由前几行组成一块区域，最后几行组成一块区域，而每块区域的权值和不就是对应那几行的数据加起来吗，然后我们可以把每一行数据先加起来看成一个值，假如说第一块区域由前3行组成，那么第一块区域的权值和就是第一行的权值和加上第二行的权值和再加上第三行的权值和，这样一来一个二位数组其实就可以看成是一维数组，一维数组的每个值对应的就是二维数组每一行的权值和，这样一来这个开发商问题就转化成了将一维数组划分为两个子数组，然后求两个子数组的最小差值的问题。

纵向划分也是同理。

问题一转化思路就清晰了，用前缀和就非常好求。假如我们的到一个横向划分的前缀和数组row[3]，row[0]代表前一行的权值和，row[1]代表前2行的权值和.....，此时我们就可以遍历所有划分情况，然后计算每一种划分情况的两块区域差值，比如以第一行为一个区域，剩下两行为另一个区域，那么这两区域的差值就是row[2]-row[0]*2，首先row[2]-row[0]就是第二个区域的权值和，再减去row[0]才是两个区域的差值。

要注意的是计算差值一定要关注需不需要求结果的绝对值，这题显然是要的。

代码如下

```java
import java.util.Scanner;

//开发商购买土地
public class KamaCoder44 {
    public static void main(String[] args) {
        buyLand();
    }

    public static void buyLand() {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int[][] lands = new int[n][m];
        //min表示两块区域土地的最小权值差
        int min = Integer.MAX_VALUE;
        //输入土地的权值，并顺便统计横向土地权值和以及纵向土地权值和
        //row[i]表示第i行的所有土地的权值和
        int[] row = new int[n];
        //column[j]表示第j列的所有土地权值和
        int[] column = new int[m];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                lands[i][j] = sc.nextInt();
                row[i] += lands[i][j];
                column[j] += lands[i][j];
            }
        }

        //计算横向前缀和，preRow[i]表示前i行的所有土地权值和
        int[] preRow = new int[n];
        preRow[0] = row[0];
        for (int i = 1; i < row.length; i++) {
            preRow[i] = preRow[i - 1] + row[i];
        }

        //计算纵向前缀和，preColumn[j]表示前j列的所有土地的权值和
        int[] preColumn = new int[m];
        preColumn[0] = column[0];
        for (int i = 1; i < column.length; i++) {
            preColumn[i] = preColumn[i - 1] + column[i];
        }

        //横向划分
        for (int i = 1; i < preRow.length; i++) {
            int dif = Math.abs(preRow[preRow.length - 1] - preRow[i - 1]*2);
            min = dif < min ? dif : min;
        }

        //纵向划分
        for (int i = 1; i < preColumn.length; i++) {
            int dif = Math.abs(preColumn[preColumn.length - 1] - preColumn[i - 1]*2);
            min = dif < min ? dif : min;
        }
        System.out.println(min);

    }
}
```





# 链表

## 1.链表理论基础

### 链表节点的定义

```java
public class ListNode {
    //节点的值
    int val;

    //下一个节点的地址
    ListNode next;

    public ListNode() {
    }

    public ListNode(int val) {
        this.val = val;
    }

    //这个好像不大需要
//    public ListNode(ListNode next) {
//        this.next = next;
//    }

    public ListNode(int val, ListNode next) {
        this.val = val;
        this.next = next;
    }
}
```





## 2.移出链表元素

### 题目

[力扣题目链接](https://leetcode.cn/problems/remove-linked-list-elements/)

题意：删除链表中等于给定值 val 的所有节点。

示例 1： 输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5]

示例 2： 输入：head = [], val = 1 输出：[]

示例 3： 输入：head = [7,7,7,7], val = 7 输出：[]



### 思路

删除链表元素的思路没什么好讲的，就是遍历然后判断要不要删。

主要要知道的是涉及链表元素操作的两种方式：

1.直接使用原来的链表进行操作

这种方式在删除节点的时候是通过要删除节点前面那个节点来删除的，但是头节点前面没有节点，因此要单独处理头节点。

头节点的处理也很简单，当判断头节点符合被删除的要求时，只需要将头节点往前移，这样就相当于删除了原来的头节点。



2.设置一个虚拟头节点再进行操作

这种方式的好处在于删除头节点的操作方式与删除其他节点的方式一样了，因此不用单独处理头节点



这题我用的是第二种方式，代码如下，我一开始写的代码不是下面这样的，写的很烂，所以好好学一学下面的代码吧。

```java
public static ListNode removeElements(ListNode head, int val) {
    //参考的别人的代码
    ListNode dummyNode = new ListNode();
    dummyNode.next = head;
    //创建一个当前节点
    ListNode currentNode = dummyNode;
    while(currentNode.next!=null){
        if(currentNode.next.val==val){
            currentNode.next=currentNode.next.next;
        }else {
            currentNode=currentNode.next;
        }
    }
    return dummyNode.next;
}
```



## 3.设计链表

### 题目

[力扣题目链接](https://leetcode.cn/problems/design-linked-list/)

题意：

在链表类中实现这些功能：

- get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。
- addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。
- addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。
- addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。
- deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。

![707示例](./pictures/20200814200558953.png)

### 思路

这道题模拟了链表的几个操作，用来熟悉练习链表非常不错。

做这道题我出现的问题主要是自己对链表这一数据结构没有一个标准的概念，我知道什么是链表，也直到链表怎么实现，但是实现链表的方式不止一种，在写这个代码的时候，我脑袋里一会儿想这这种实现方式，一会儿有想到了那种实现方式，导致整个过程非常混乱，思路不清晰。

所以我觉得做这种题，首先就要先明确自己到底要用那种方式，例如要先弄清楚size代表什么，是当前链表最大索引还是当前链表长度，再如链表要不要虚拟头节点。把这些基本的东西搞清除，制定一个规范再下笔，思路才会更清晰。

代码如下

```java
//设计链表
public class LeetCode707 {

}


/**
 * 在模拟链表这种数据结构的时候最好能有一个统一的规定，例如要先弄清楚size代表什么，是当前链表最大索引还是当前链表长度，再如链表要不要虚拟头节点。
 * 有一个统一的规定模拟起来才不会混乱，再下次遇到的时候心里也有一个整体的规范，不然脑袋里面就会变来变去，非常影响编写代码
 * 这里我就做一个统一的规范，以后遇到链表相关的模拟就按这个规范来
 * 1.采用单链表，一个节点只包含val和next
 * 2.采用虚拟头节点
 * 3.size代表链表的实际长度
 */
class MyLinkedList {
    class ListNode {
        int val;
        ListNode next;

        ListNode() {
        }

        ListNode(int val, ListNode next) {
            this.val = val;
            this.next = next;
        }
    }

    //链表的虚拟头节点
    ListNode head;
    //链表的实际长度
    int size;

    public MyLinkedList() {
        //初始化链表
        head = new ListNode();
        size = 0;
    }

    public int get(int index) {
        //获取指定索引的节点
        //首先处理非法索引
        if(index<0||index>=size){
            return -1;
        }
        //当前节点
        ListNode cur = head;
        for (int i = 0; i <= index; i++) {
            cur=cur.next;
        }
        return cur.val;
    }

    public void addAtHead(int val) {
        //在头节点前面添加元素
        //让新节点的next指向原来的头节点
        ListNode newNode = new ListNode(val,head.next);
        //只需让虚拟头节点指向要添加的节点即可
        head.next = newNode;
        //别忘了让链表的长度+1
        size++;
    }

    public void addAtTail(int val) {
        //在尾节点后面添加元素
        ListNode cur = head;
        //先遍历节点，一直到尾节点
        while(cur.next!=null){
            cur=cur.next;
        }
        //创建一个新节点并让旧尾节点指向新尾节点
        ListNode newNode = new ListNode(val,null);
        cur.next=newNode;
        //别忘了让链表长度+1
        size++;
    }

    public void addAtIndex(int index, int val) {
        //在指定索引位置添加元素
        //首先处理非法索引，在这里索引为size的情况并不是非法情况，如果索引为size，说明新节点是插入到链表尾部的
        if(index<0||index>size){
            return;
        }
        //遍历链表，直到目标索引的前驱节点
        ListNode cur = head;
        for (int i = 0; i < index; i++) {
            cur=cur.next;
        }
        //新建要插入的节点，并让新节点指向原来在这个索引位置的节点
        ListNode newNode = new ListNode(val,cur.next);
        //让前驱节点指向新节点
        cur.next=newNode;
        //别忘了让链表长度+1
        size++;
    }

    public void deleteAtIndex(int index) {
        //删除指定索引的节点
        //处理非法索引
        if(index<0||index>=size){
            return;
        }
        ListNode cur = head;
        //遍历到要删除节点的前驱节点
        for (int i = 0; i < index; i++) {
            cur=cur.next;
        }
        //直接让前驱节点指向被删除节点的下一个节点即可
        cur.next=cur.next.next;
        //别忘了让链表长度-1
        size--;
    }
}
```





## 4.翻转链表

### 题目

[力扣题目链接](https://leetcode.cn/problems/reverse-linked-list/)

题意：反转一个单链表。

示例: 输入: 1->2->3->4->5->NULL 输出: 5->4->3->2->1->NULL



### 思路

采用双指针法。定义一个cur指针代表当前节点，定义一个pre代表前驱节点，定义一个tmp代表临时节点，临时节点用于保存下一个节点的位置。

翻转时，只需将cur的next指向pre即可，完成翻转后cur和pre都向前移动一个节点直到翻转完所有节点

代码如下

```java
//反转链表
public class LeetCode206 {

}
class Solution {
    public ListNode reverseList(ListNode head) {
        //双指针法
        //当前节点
        ListNode cur = head;
        //前驱节点
        ListNode pre = null;
        //临时节点
        ListNode tmp = null;
        while(cur!=null){
            //保存下一个节点的位置
            tmp=cur.next;
            cur.next=pre;
            //两个指针都向前移动一个节点
            pre=cur;
            cur=tmp;
        }
        return pre;
    }
}

//LeetCode题目给的链表节点类，不是我自己定义的
class ListNode {
      int val;
      ListNode next;
      ListNode() {}
      ListNode(int val) { this.val = val; }
      ListNode(int val, ListNode next) { this.val = val; this.next = next; }
  }
```





## 5.两两交换链表中的节点

### 题目

[力扣题目链接](https://leetcode.cn/problems/swap-nodes-in-pairs/)

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

![24.两两交换链表中的节点-题意](./pictures/24.两两交换链表中的节点-题意.jpg)



### 思路

思路就是模拟，但是模拟这东西真的是想着挺简单的，但是一敲代码真的有好多细节需要注意。

首先要想好模拟的过程，在脑袋里面要有一个清晰的过程，最好就拿草稿纸来写一下，不要太相信自己的脑袋，这道题我也并没有一遍过，代码写出来有有几个漏洞

模拟过程如下

先让当前节点指向第二个节点，然后让第二个指向第一个节点完成交换，最后让第一个节点指向第三个节点。这里特别要注意，第三个节点的地址要用一个临时变量记住，我就是在这里踩了坑。

![24.两两交换链表中的节点1](./pictures/24.两两交换链表中的节点1.png)

代码如下

```java
import dataStructure.ListNode;

//两两交换链表中的节点
public class LeetCode24 {
    public ListNode swapPairs(ListNode head) {
        //处理空链表和长度为1的链表的情况
        if(head==null||head.next==null){
            return null;
        }
        //记住第二个节点，最后直接返回这个节点
        ListNode newHead = head.next;
        //使用虚拟头节点
        //让cur指向虚拟头节点
        ListNode cur = new ListNode(0,head);
        //如果当前节点为空并且当前节点后面的节点数不少于两个，就两两交换处理
        while(cur!=null&&cur.next!=null&&cur.next.next!=null){
            //创建两个变量来代表进行两两交换的节点，会让思路清晰一点
            ListNode first = cur.next;
            ListNode second = cur.next.next;
            //临时变量记住第三个节点
            ListNode tmp = second.next;
            //让当前节点指向第二个节点
            cur.next=second;
            //让第二个节点指向第一个节点
            second.next=first;
            //让第一个节点指向第二个节点的下一个节点
            //first.next=second.next;   这里注意一下，我第一次写的代码是这样的，但是前面second.next已经被修改了，所以这行代码实际上first.next=first，指向自己了
            //应该用于个临时变量来记住第三个节点
            first.next=tmp;
            //让当前节点的指针向前移动
            //cur=second;		这里也注意一下，我第一次写的是cur=second，脑袋里面想的确实是让cur向前移动两个节点，但是由于第一个节点和第二个节点已经交换了，此时第二个节点已经变成第一个节点，第一个节点变成第二个节点了，所以应该是cur=first;
            cur=first;
        }
        //处理好后直接返回处理前的第二个节点
        return newHead;
    }
}
```





## 6.删除链表的倒数第N个节点

### 题目

[力扣题目链接](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

进阶：你能尝试使用一趟扫描实现吗？

示例 1：

![19.删除链表的倒数第N个节点](./pictures/20210510085957392.png)

输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5]

示例 2：

输入：head = [1], n = 1 输出：[]

示例 3：

输入：head = [1,2], n = 1 输出：[1]





### 思路

采用快慢指针法。

定义一个fast指针和一个slow指针同时指向开始节点（最好指向虚拟头节点）

先让fast指针向前移动n个节点

接着让slow和fast指针同时向前移动，直到fast到达链表的末尾，即：fast指针为null，注意不是指向尾节点，而是链表的结尾null

这时slow所指的节点就是要删除的节点



代码如下

```java
import dataStructure.ListNode;

//删除链表的倒数第N个节点
public class LeetCode19 {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        /*思路：
        *快慢指针
        * 定义一个快指针fast和一个慢指针slow
        * 让fast先移动n个节点
        * 然后slow和fast同时移动，直到fast到达末尾，注意不是最后一个节点，而是链表的末尾，即：最后fast指针为null
        * 此时slow指向的节点就是要删除的节点
        * */

        //定义一个虚拟头节点
        ListNode dummy = new ListNode(0,head);
        //快指针,指向虚拟节点
        ListNode fast = dummy;
        //慢指针,指向虚拟节点
        ListNode slow = dummy;
        //快指针先移动n+1个节点，正常来说移动n个节点就可以了，这里移动n+1个节点是为了让slow指针指向要删除的节点的前驱节点，方便进行删除操作
        for (int i = 0; i < n+1; i++) {
            //注意处理异常情况，如果fast在这个过程中变为了null，说明倒数第n个节点根本不存在，直接返回原来的链表
            if(fast==null){
                return head;
            }
            fast=fast.next;
        }
        //接着让快慢指针同时移动，直到fast指向结尾的null
        while(fast!=null){
            fast=fast.next;
            slow=slow.next;
        }
        //循环结束，找到要删除节点的前驱节点，进行删除操作
        slow.next=slow.next.next;
        //返回虚拟头节点指向的节点，即新的头节点
        return dummy.next;
    }
}
```





## 7.链表相交

### 题目

同：160.链表相交

[力扣题目链接](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)

给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。

图示两个链表在节点 c1 开始相交：

![img](./pictures/20211219221657.png)

题目数据 保证 整个链式结构中不存在环。

注意，函数返回结果后，链表必须 保持其原始结构 。

示例 1：

![img](./pictures/20211219221723.png)

示例 2：

![img](./pictures/20211219221749.png)

示例 3：

![img](./pictures/20211219221812.png)![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20211219221812.png)





### 思路

首先要明白什么是链表相交：链表相交是指两个链表在某个节点开始合并，共享相同的节点序列。

明白了链表相交的概念才能正确解题，我刚开始都不明白链表相交是啥。

思路如下：

首先统计A、B两条链表的长度，假设分别为n、m

使用curA、curB两个指针分别指向A、B链表

将两条链表尾部对齐，这里假设m>n，那么对齐方式就是curB先向前移动m-n个节点

尾部对齐后，curA和curB同时向前移动，移动的同时判断curA和curB地址是否相同，如果地址相同，那么该节点就是链表相交的起始节点



代码如下

```java
import dataStructure.ListNode;

//链表相交
public class LeetCode160 {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        /*思路：
         * 首先统计A、B两条链表的长度，假设分别为n、m
         * 使用curA、curB两个指针分别指向A、B链表
         * 将两条链表尾部对齐，这里假设m>n，那么对齐方式就是curB先向前移动m-n个节点
         * 尾部对齐后，curA和curB同时向前移动，移动的同时判断curA和curB地址是否相同，如果地址相同，那么该节点就是链表相交的起始节点
         * */

        //curA指针指向链表A
        ListNode curA = headA;
        //curB指针指向链表B
        ListNode curB = headB;
        //计算链表A的长度
        int lenA = 0;
        while (curA != null) {
            lenA++;
            curA = curA.next;
        }
        curA = headA;

        //计算链表B的长度
        int lenB = 0;
        while (curB != null) {
            lenB++;
            curB = curB.next;
        }
        curB=headB;

        //尾部对齐
        //如果链表A长
        if(lenA>lenB){
            for (int i = 0; i < lenA-lenB; i++) {
                curA=curA.next;
            }
        }
        //如果链表B长
        if(lenA<lenB){
            for (int i = 0; i < lenB-lenA; i++) {
                curB=curB.next;
            }
        }

        //尾部对齐后开始寻找链表相交的起始节点
        while(curA!=null){
            if(curA==curB){
                return curA;
            }else{
                curA=curA.next;
                curB=curB.next;
            }
        }
        return null;
    }
}
```





## 8.环形链表II

### 题目

[力扣题目链接](https://leetcode.cn/problems/linked-list-cycle-ii/)

题意： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。

**说明**：不允许修改给定的链表。

![循环链表](./pictures/20200816110112704.png)



### 思路

这道题的思路我是第一次见，以前从来没有写过这样的题，长见识了。这里笔记直接复制的原资料中的讲的思路



这道题目，不仅考察对链表的操作，而且还需要一些数学运算。

主要考察两知识点：

- 判断链表是否环
- 如果有环，如何找到这个环的入口

### 判断链表是否有环

可以使用快慢指针法，分别定义 fast 和 slow 指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。

为什么fast 走两个节点，slow走一个节点，有环的话，一定会在环内相遇呢，而不是永远的错开呢

首先第一点：**fast指针一定先进入环中，如果fast指针和slow指针相遇的话，一定是在环中相遇，这是毋庸置疑的。**

那么来看一下，**为什么fast指针和slow指针一定会相遇呢？**

可以画一个环，然后让 fast指针在任意一个节点开始追赶slow指针。

会发现最终都是这种情况， 如下图：

![142环形链表1](./pictures/20210318162236720.png)

fast和slow各自再走一步， fast和slow就相遇了

这是因为fast是走两步，slow是走一步，**其实相对于slow来说，fast是一个节点一个节点的靠近slow的**，所以fast一定可以和slow重合。

动画如下：

![141.环形链表](./pictures/141.环形链表.gif)

### 如果有环，如何找到这个环的入口

**此时已经可以判断链表是否有环了，那么接下来要找这个环的入口了。**

假设从头结点到环形入口节点 的节点数为x。 环形入口节点到 fast指针与slow指针相遇节点 节点数为y。 从相遇节点 再到环形入口节点节点数为 z。 如图所示：

![img](./pictures/20220925103433.png)

那么相遇时： slow指针走过的节点数为: `x + y`， fast指针走过的节点数：`x + y + n (y + z)`，n为fast指针在环内走了n圈才遇到slow指针， （y+z）为 一圈内节点的个数A。

因为fast指针是一步走两个节点，slow指针一步走一个节点， 所以 fast指针走过的节点数 = slow指针走过的节点数 * 2：

```
(x + y) * 2 = x + y + n (y + z)
```

两边消掉一个（x+y）: `x + y = n (y + z)`

因为要找环形的入口，那么要求的是x，因为x表示 头结点到 环形入口节点的的距离。

所以要求x ，将x单独放在左面：`x = n (y + z) - y` ,

再从n(y+z)中提出一个 （y+z）来，整理公式之后为如下公式：`x = (n - 1) (y + z) + z` 注意这里n一定是大于等于1的，因为 fast指针至少要多走一圈才能相遇slow指针。

这个公式说明什么呢？

先拿n为1的情况来举例，意味着fast指针在环形里转了一圈之后，就遇到了 slow指针了。

当 n为1的时候，公式就化解为 `x = z`，

这就意味着，**从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点**。

也就是在相遇节点处，定义一个指针index1，在头结点处定一个指针index2。

让index1和index2同时移动，每次移动一个节点， 那么他们相遇的地方就是 环形入口的节点。

动画如下：

![142.环形链表II（求入口）](./pictures/142.环形链表II（求入口）.gif)

那么 n如果大于1是什么情况呢，就是fast指针在环形转n圈之后才遇到 slow指针。

其实这种情况和n为1的时候 效果是一样的，一样可以通过这个方法找到 环形的入口节点，只不过，index1 指针在环里 多转了(n-1)圈，然后再遇到index2，相遇点依然是环形的入口节点。



### 补充

在推理过程中，大家可能有一个疑问就是：**为什么第一次在环中相遇，slow的 步数 是 x+y 而不是 x + 若干环的长度 + y 呢？**

即文章[链表：环找到了，那入口呢？](https://programmercarl.com/0142.环形链表II.html)中如下的地方：

![142环形链表5](./pictures/20210318165123581.png)

首先slow进环的时候，fast一定是先进环来了。

如果slow进环入口，fast也在环入口，那么把这个环展开成直线，就是如下图的样子：

![142环形链表3](./pictures/2021031816503266.png)

可以看出如果slow 和 fast同时在环入口开始走，一定会在环入口3相遇，slow走了一圈，fast走了两圈。

重点来了，slow进环的时候，fast一定是在环的任意一个位置，如图：

![142环形链表4](./pictures/2021031816515727.png)

那么fast指针走到环入口3的时候，已经走了k + n 个节点，slow相应的应该走了(k + n) / 2 个节点。

因为k是小于n的（图中可以看出），所以(k + n) / 2 一定小于n。

**也就是说slow一定没有走到环入口3，而fast已经到环入口3了**。

这说明什么呢？

**在slow开始走的那一环已经和fast相遇了**。

那有同学又说了，为什么fast不能跳过去呢？ 在刚刚已经说过一次了，**fast相对于slow是一次移动一个节点，所以不可能跳过去**。

好了，这次把为什么第一次在环中相遇，slow的 步数 是 x+y 而不是 x + 若干环的长度 + y ，用数学推理了一下，算是对[链表：环找到了，那入口呢？](https://programmercarl.com/0142.环形链表II.html)的补充。



# 哈希表

## 2.有效的字母异位词

### 题目

[力扣题目链接](https://leetcode.cn/problems/valid-anagram/)

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

示例 1: 输入: s = "anagram", t = "nagaram" 输出: true

示例 2: 输入: s = "rat", t = "car" 输出: false

**说明:** 你可以假设字符串只包含小写字母。



### 思路

首先要明白什么是字母异位词

字母异位词是通过重新排列不同单词或短语的字母而形成的单词或短语，并使用所有原字母一次。

也就是说两个单词的长度一致，所用过的字母也都一致



那么思路如下：

新建一个长度为26的整形数组，将每个字母依次映射为不同的索引，如：a映射为0，b映射为1，以此类推
首先遍历s的字符，每遍历一个字符就在对应索引位置+1
再遍历t的字符，每遍历一个字符就在对应索引位置-1
最后判断数组中是否存在不为0的位置，如果存在不为0的位置，说明s或t其中一个字符串存在多出来的字符



```java
//有效的字母异位词
public class LeetCode242 {
    public boolean isAnagram(String s, String t) {
        /*新建一个长度为26的整形数组，将每个字母依次映射为不同的索引，如：a映射为0，b映射为1，以此类推
        * 首先遍历s的字符，每遍历一个字符就在对应索引位置+1
        * 再遍历t的字符，每遍历一个字符就在对应索引位置-1
        * 最后判断数组中是否存在不为0的位置，如果存在不为0的位置，说明s或t其中一个字符串存在多出来的字符
        */

        //创建数组
        int[] arr = new int[26];
        //遍历字符串s
        for (int i = 0; i < s.length(); i++) {
            arr[s.charAt(i)-'a']++;
        }
        //遍历字符串t
        for (int i = 0; i < t.length(); i++) {
            arr[t.charAt(i)-'a']--;
        }
        //检查数组是否存在非0的位置
        for (int i : arr) {
            if(i!=0){
                return false;
            }
        }
        //如果数组所有位置都为0，说明t是s的字母异位词
        return true;
    }
}
```



## 3.两个数组的交集

### 题目

[力扣题目链接](https://leetcode.cn/problems/intersection-of-two-arrays/)

题意：给定两个数组，编写一个函数来计算它们的交集。

![349. 两个数组的交集](./pictures/20200818193523911.png)

**说明：** 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。



### 思路

学会使用set集合，set集合的特点是无序、不重复、无索引的
利用set集合来存储，这里使用HashSet，由于HashSet不存储重复的元素，因此可以很好地记录nums1中出现了哪些数字
首先遍历nums1，将nums1中出现过的数字放在HashSet集合中
再遍历nums2，在HashSet集合中寻找nums2的数字，如果找到了就说明该数字是两数组的交集的元素。
这题思路上没那么复杂，但是要注意的是数组的转换问题，因为两个数组的交集的结果到底有多少个数字我们是没法明确得知的
所以要使用可变长集合来记录交集结果，而如何把这个可变长集合变成数组就是问题所在，有两种方法来解决这个问题：
1.使用Stream流
2.再创建一个长度等于结果集长度的数组



代码如下

```java
public int[] intersection(int[] nums1, int[] nums2) {
    /*思路：
     * 学会使用set集合，set集合的特点是无序、不重复、无索引的
     * 利用set集合来存储，这里使用HashSet，由于HashSet不存储重复的元素，因此可以很好地记录nums1中出现了哪些数字
     * 首先遍历nums1，将nums1中出现过的数字放在HashSet集合中
     * 再遍历nums2，在HashSet集合中寻找nums2的数字，如果找到了就说明该数字是两数组的交集的元素。
     * 这题思路上没那么复杂，但是要注意的是数组的转换问题，因为两个数组的交集的结果到底有多少个数字我们是没法明确得知的
     * 所以要使用可变长集合来记录交集结果，而如何把这个可变长集合变成数组就是问题所在，有两种方法来解决这个问题：
     * 1.使用Stream流
     * 2.再创建一个长度等于结果集长度的数组
     * */

    //创建set集合
    Set<Integer> set = new HashSet<>();
    //遍历nums1
    for (int i : nums1) {
        set.add(i);
    }
    //遍历nums2
    //再创建一个结果集，用来存放交集结果
    Set<Integer> result = new HashSet<>();
    for (int i : nums2) {
        //如果在set集合中能够找到nums2中的数字就将其放入结果集
        if(set.contains(i)){
            result.add(i);
        }
    }

    //方法2，创建一个长度与结果集相同的数组
    int[] arr = new int[result.size()];
    int i=0;
    for (Integer value : result) {
        arr[i++]=value;
    }


    //将集合转换成数组
    //方法1，使用Stream流
    return result.stream().mapToInt(new ToIntFunction<Integer>() {
        @Override
        public int applyAsInt(Integer value) {
            return value.intValue();
        }
    }).toArray();

}
```





## 4.快乐数

### 题目

[力扣题目链接](https://leetcode.cn/problems/happy-number/)

编写一个算法来判断一个数 n 是不是快乐数。

「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为 1，那么这个数就是快乐数。

如果 n 是快乐数就返回 True ；不是，则返回 False 。

**示例：**

输入：19
输出：true
解释：
1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1



### 思路

用一个Set集合来存储每次数字平方和的结果
每次计算平方和的时候都在Set集合里面找一下有没有重复的结果，如果有，说明出现了循环，直接返回false
没有重复就接着计算平方和，直到最后结果变为1

```java
import java.util.HashSet;
import java.util.Set;

//快乐数
public class LeetCode202 {

    public boolean isHappy_My(int n) {
        /*思路：
         * 用一个Set集合来存储每次数字平方和的结果
         * 每次计算平方和的时候都在Set集合里面找一下有没有重复的结果，如果有，说明出现了循环，直接返回false
         * 没有重复就接着计算平方和，直到最后结果变为1
         * */

        Set<Integer> set = new HashSet<>();
        //临时变量，用于计算平方和，tmp用于记住n的值，sum用于记住平方和的值，bit表示每一位的数字
        int tmp = 0;
        int sum = 0;
        int bit = 0;

        while (n != 1) {
            //计算平方和
            tmp = n;
            while (tmp != 0) {
                bit = tmp % 10;
                sum += bit * bit;
                tmp /= 10;
            }
            //判断是否重复
            if (set.contains(sum)) {
                return false;
            }
            set.add(sum);
            n = sum;
            sum = 0;
        }
        return true;
    }

    public boolean isHappy(int n) {
        //思路是一样的，但是代码的写法不一样，参考的别人的写法

        Set<Integer> record = new HashSet<>();

        while (n != 1 && !record.contains(n)) {
            record.add(n);
            n = nextNumber(n);
        }
        return n==1;
    }

    public int nextNumber(int n) {
        //该方法返回n的每位的平方和
        int sum = 0;
        while (n > 0) {
            int tmp = n%10;
            sum+=tmp*tmp;
            n/=10;
        }
        return sum;
    }
}
```



## 5.两数之和

### 题目

[力扣题目链接](https://leetcode.cn/problems/two-sum/)

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

**示例:**

给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9

所以返回 [0, 1]



### 思路

这题使用的是哈希法，前面`2.有效的字母异位词`和`3.两个数组的交集`也是用的哈希法。

那么我们到底要在什么时候使用哈希法呢？当我们需要查询一个元素是否出现过，或者一个元素是否在集合里时，就要采用哈希法。



本题思路：

我自己思考时想用Set集合，要遍历两次数组，第一次遍历时，用Set集合记录target-nums[i]，第二次遍历时，去Set集合里面找有没有nums[i]这个元素，如果有说明这是要找的元素之一，记录当前元素的下标值，找到两个集合中存在的元素就可以返回结果了



别人的思路是使用一个Map集合，为什么使用Map集合而不使用Set集合呢？因为使用Map集合可以让key记录数组元素值，让value记录数组元素下标，这样就可以直接获取到下标了，比较方便快捷。

使用Map集合就只用遍历一次数组，每遍历一个元素就去Map集合中寻找有没有合适的值，这个合适的值就是target-nums[i]。如果找到了这个值，就将该值的下标获取出来，然后直接返回当前遍历元素的下标和获取出来的下标即可。

如果没有找到合适的值，就将当前遍历的数组元素及其下标存入Map集合中。



代码如下

```java
import java.util.HashMap;
import java.util.Map;

//两数之和
public class LeetCode1 {
    public int[] twoSum(int[] nums, int target) {
        /*思路：
        * 使用一个Map集合来记录已经访问过的数组元素，Map集合的Key代表数组元素，Value代表元素下标
        * 每遍历一个数组元素，就到Map集合中去寻找有没有合适的元素，即：找有没有元素与当前遍历的元素相加结果为target
        * 如：当前遍历数组元素值为2，目标值为9，那就去Map集合中找有没有7这个元素
        *
        * */

        Map<Integer,Integer> record = new HashMap<>();
        int[] result = new int[2];
        //遍历数组
        for (int i = 0; i < nums.length; i++) {
            if(record.containsKey(target-nums[i])){
                result[0]=i;
                result[1]=record.get(target-nums[i]);
                return result;
            }
            record.put(nums[i],i);
        }
        return result;
    }
}
```





## 6.四数相加II

### 题目

[力扣题目链接](https://leetcode.cn/problems/4sum-ii/)

给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。

为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。

**例如:**

输入:

- A = [ 1, 2]
- B = [-2,-1]
- C = [-1, 2]
- D = [ 0, 2]

输出:

2

**解释:**

两个元组如下:

1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0



### 思路

如果存在满足要求的元组，那么元组中前两个数，即nums1和nums2中的数的和一定和后两个数，即nums3和nums4中的数的和是互为相反数的
也就是说我们可以先统计前两个数组的所有可能的相加结果，用一个map集合存储，key为相加结果，value为该相加结果出现的次数
接着我们遍历后面两个数组，如果它们中的两个数相加的结果的相反数刚好在map集合中出现过，就说明找到了合适的元组，取出该相反数对应的值加到最终的统计结果中

画了张图，也不知道自己后面回来复习能不能看懂

![9efcba042d349398f6d3b54c2c27220](./pictures/9efcba042d349398f6d3b54c2c27220.jpg)



```java
import java.util.HashMap;
import java.util.Map;

//四数相加
public class LeetCode454 {
    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
        /*思路：
         * 如果存在满足要求的元组，那么元组中前两个数，即nums1和nums2中的数的和一定和后两个数，即nums3和nums4中的数的和是互为相反数的
         * 也就是说我们可以先统计前两个数组的所有可能的相加结果，用一个map集合存储，key为相加结果，value为该相加结果出现的次数
         * 接着我们遍历后面两个数组，如果它们中的两个数相加的结果的相反数刚好在map集合中出现过，就说明找到了合适的元组，取出该相反数对应的值加到最终的统计结果中
         */


        //map集合，用于存储前两个数组遍历的结果
        Map<Integer,Integer> map = new HashMap<>();
        //count用于统计满足要求的元组个数
        int count=0;

        //遍历前两个数组
        for (int num1 : nums1) {
            for (int num2 : nums2) {
               Integer key = num1+num2;
               map.put(key,map.getOrDefault(key,0)+1);
            }
        }

        //遍历后面两个数组
        for (int num3 : nums3) {
            for (int num4 : nums4) {
                Integer key = 0-num3-num4;
                count+=map.getOrDefault(key,0);
            }
        }
        return count;
    }
}
```





## 7.赎金信

### 题目

[力扣题目链接](https://leetcode.cn/problems/ransom-note/)

给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。

(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)

**注意：**

你可以假设两个字符串均只含有小写字母。

canConstruct("a", "b") -> false
canConstruct("aa", "ab") -> false
canConstruct("aa", "aab") -> true



### 思路

和前面`2.有效的字母异位词`题目非常类似

创建一个长度为26的整形数组ch[]，ch[0]代表字母a出现的次数，ch[1]代表字母b出现的次数，以此类推
首先遍历ransomNote中的字符，用ch[]来统计每一个字符出现的次数
接着遍历magazine中的字符，每遍历一个字符就在ch[]中让其对应的次数减1
最后判断ch[]中是否存在大于0的元素，如果存在说明ransomNote不能由magazine的字符构成，反之则能。



```java
//383.赎金信
public class LeetCode383 {
    public boolean canConstruct(String ransomNote, String magazine) {
        /**思路：
         * 创建一个长度为26的整形数组ch[]，ch[0]代表字母a出现的次数，ch[1]代表字母b出现的次数，以此类推
         * 首先遍历ransomNote中的字符，用ch[]来统计每一个字符出现的次数
         * 接着遍历magazine中的字符，每遍历一个字符就在ch[]中让其对应的次数减1
         * 最后判断ch[]中是否存在大于0的元素，如果存在说明ransomNote不能由magazine的字符构成，反之则能。
         */

        if(ransomNote.length()>magazine.length()){
            //如果ransomNote的长度大于magazine，说明ransomNote根本不可能由magazine构成
            return false;
        }

        //创建数组
        int[] ch = new int[26];
        //遍历ransomNote中的字符
        for (int i = 0; i < ransomNote.length(); i++) {
            ch[ransomNote.charAt(i)-'a']++;
        }
        //遍历magazine中的字符
        for (int i = 0; i < magazine.length(); i++) {
            ch[magazine.charAt(i)-'a']--;
        }
        //判断ch[]中是否存在大于0的元素
        for (int i : ch) {
            if(i>0){
                return false;
            }
        }
        return true;
    }
}
```







## 8.三数之和

### 题目

[力扣题目链接](https://leetcode.cn/problems/3sum/)

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。

**注意：** 答案中不可以包含重复的三元组。

示例：

给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]



### 思路

这里直接复制资料中的思路



 双指针

**其实这道题目使用哈希法并不十分合适**，因为在去重的操作中有很多细节需要注意，在面试中很难直接写出没有bug的代码。

而且使用哈希法 在使用两层for循环的时候，能做的剪枝操作很有限，虽然时间复杂度是O(n^2)，也是可以在leetcode上通过，但是程序的执行时间依然比较长 。

接下来我来介绍另一个解法：双指针法，**这道题目使用双指针法 要比哈希法高效一些**，那么来讲解一下具体实现的思路。

动画效果如下：

![15.三数之和](./pictures/15.三数之和.gif)

拿这个nums数组来举例，首先将数组排序，然后有一层for循环，i从下标0的地方开始，同时定一个下标left 定义在i+1的位置上，定义下标right 在数组结尾的位置上。

依然还是在数组中找到 abc 使得a + b +c =0，我们这里相当于 a = nums[i]，b = nums[left]，c = nums[right]。

接下来如何移动left 和right呢， 如果nums[i] + nums[left] + nums[right] > 0 就说明 此时三数之和大了，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些。

如果 nums[i] + nums[left] + nums[right] < 0 说明 此时 三数之和小了，left 就向右移动，才能让三数之和大一些，直到left与right相遇为止。





去重逻辑

a的去重

说到去重，其实主要考虑三个数的去重。 a, b ,c, 对应的就是 nums[i]，nums[left]，nums[right]

a 如果重复了怎么办，a是nums里遍历的元素，那么应该直接跳过去。

但这里有一个问题，是判断 nums[i] 与 nums[i + 1]是否相同，还是判断 nums[i] 与 nums[i-1] 是否相同。

有同学可能想，这不都一样吗。

其实不一样！

都是和 nums[i]进行比较，是比较它的前一个，还是比较它的后一个。

如果我们的写法是 这样：

```text
if (nums[i] == nums[i + 1]) { // 去重操作
    continue;
}
```

那我们就把 三元组中出现重复元素的情况直接pass掉了。 例如{-1, -1 ,2} 这组数据，当遍历到第一个-1 的时候，判断 下一个也是-1，那这组数据就pass了。

**我们要做的是 不能有重复的三元组，但三元组内的元素是可以重复的！**

所以这里是有两个重复的维度。

那么应该这么写：

```text
if (i > 0 && nums[i] == nums[i - 1]) {
    continue;
}
```

这么写就是当前使用 nums[i]，我们判断前一位是不是一样的元素，在看 {-1, -1 ,2} 这组数据，当遍历到 第一个 -1 的时候，只要前一位没有-1，那么 {-1, -1 ,2} 这组数据一样可以收录到 结果集里。

这是一个非常细节的思考过程



代码

```java
import java.util.*;

//15.三数之和
public class LeetCode15 {

    public static void main(String[] args){
        System.out.println(threeSum(new int[]{-2,0,1,1,2}));
    }



    public static List<List<Integer>> threeSum(int[] nums){
        //参考别人写的代码
        List<List<Integer>> result = new ArrayList<>();
        //数组排序
        Arrays.sort(nums);
        //如果排序后的第一个元素就大于0，那么不可能存在元组和为0的情况
        if(nums[0]>0){
            return result;
        }

        for (int i = 0; i < nums.length; i++) {
            //去除重复情况
            //去重逻辑需要学习一下，如果元组的第一个数相等，在寻找元组后面两个数时由于寻找范围就是在nums这个数组中，因此符合题意的元组肯定也是一样的
            //因此只要第一个元素重复了，就说明元组也会重复
            //而这里是判断nums[i]==nums[i--]而不是nums[i]==nums[i++]
            //这是因为如果是后面的判断方式，会导致元组内部中不能出现重复元素，但是元组内出现重复元素是允许的，比如元组：-1,-1,2
            if(i>0&&nums[i]==nums[i-1]){
                continue;
            }
            int left=i+1;
            int right=nums.length-1;

            while(left<right){
                int sum = nums[i]+nums[left]+nums[right];
                if(sum>0){
                    //如果当前和的元组和大于0，就左移right指针，尝试减小当前元组和
                    right--;
                }else if (sum<0){
                    //如果当前和的元组和小于0，就右移left指针，尝试增大当前元组和
                    left++;
                }else {
                    result.add(Arrays.asList(nums[i],nums[left],nums[right]));
                    //对元组的后面两个数字去重，让当前找到的元组只会出现一次
                    while(left<right && nums[right]==nums[right-1]) right--;
                    while(left<right && nums[left]==nums[left+1]) left++;

                    //接着寻找新的元组
                    right--;
                    left++;
                }

            }

        }

        return result;
    }


    public static List<List<Integer>> threeSum_My(int[] nums) {
        //自己写的代码
        /**
         * 思路：双指针法
         * 首先将数组排序
         * 定义一个left和right指针
         * 接下来遍历数组，i表示索引，最开始时，i指向索引0，left指向索引i+1的元素，right指向最后一个元素
         * 计算两个指针和当前遍历到的元素nums[i]的和
         * 如果这个和小于0，就移动left，尝试让和变大；如果这个和大于0，就移动right，尝试让这个和变小
         * 直到这个和变为0或者left和right指针相遇，和变为0就记录这个元组
         * 接着让i索引加1，遍历下一个元素，left依然指向索引为i+1的元素，right依然指向最后一个元素
         * 再按照上面的步骤找到和为0的元组
         * 一直遍历，直到遍历完所有元素，即i指向数组倒数第三个元素时。
         */

        //返回结果
        Set<List<Integer>> result = new HashSet<>();

        //数组排序
        Arrays.sort(nums);
        //定义指针
        int left;
        int right;
        //遍历数组
        for (int i = 0; i < nums.length-2; i++) {
            left = i + 1;
            right=nums.length-1;
            int sum = nums[i] + nums[left] + nums[right];
            while (left < right) {
                if (sum>0){
                    //如果元组和大于0，就左移right指针，尝试减小这个和
                    right--;
                }else if(sum<0){
                    //如果元组和小于0，就右移left指针，尝试增大这个和
                    left++;
                }else{
                    //记录元组
                    List<Integer> list = new ArrayList<>();
                    list.add(nums[i]);
                    list.add(nums[left]);
                    list.add(nums[right]);
                    result.add(list);
                    left++;
                    right--;
                }
                sum=nums[i]+nums[left]+nums[right];
            }
        }
        return result.stream().toList();
    }
}
```





## 9.四数之和

### 题目

[力扣题目链接](https://leetcode.cn/problems/4sum/)

题意：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。

**注意：**

答案中不可以包含重复的四元组。

示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]



### 思路

将四数之和分解为一个数和三个数之和
即：如果四数之和目标值为target，那么我们从nums中任意取出一个值nums[i]
然后再去找剩下三个值，剩下三个值的目标值就是target-nums[i]
然后再用之前写三数之和的方法去找那三个数

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

//四数之和
public class LeetCode18 {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        /**
         * 思路：
         * 将四数之和分解为一个数和三个数之和
         * 即：如果四数之和目标值为target，那么我们从nums中任意取出一个值nums[i]
         * 然后再去找剩下三个值，剩下三个值的目标值就是target-nums[i]
         * 然后再用之前写三数之和的方法去找那三个数
         */

        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums);

        //剪枝
        if(target<nums[0]&&nums[0]>0){
            return result;
        }

        for (int i = 0; i < nums.length; i++) {
            //取出第一个数
            //去重
            if(i>0&&nums[i]==nums[i-1]){
                continue;
            }
            
            //寻找剩下三个数
            for (int j = i+1; j < nums.length; j++) {
                //去重
                if(j>i+1&&nums[j]==nums[j-1]){
                    continue;
                }
                int left=j+1;
                int right=nums.length-1;
                while(left<right){
                    int sum = nums[i]+nums[j]+nums[left]+nums[right];
                    if(sum>target){
                        //如果元组和大于目标值，就左移right指针，尝试减小元组的和
                        right--;
                    }else if(sum<target){
                        //如果元组和小于目标值，就右移left指针，尝试增大元组的和
                        left++;
                    }else{
                        //如果元组和等于目标值，记录元组
                        result.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right]));
                        //去重
                        while(left<right&&nums[right]==nums[right-1]) right--;
                        while(left<right&&nums[left]==nums[left+1]) left++;

                        right--;
                        left++;
                    }
                }
            }
        }
        return result;
    }

}
```





# 字符串

## 1.反转字符串

### 题目

[力扣题目链接](https://leetcode.cn/problems/reverse-string/)

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。

示例 1：
输入：["h","e","l","l","o"]
输出：["o","l","l","e","h"]

示例 2：
输入：["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]



### 思路

这个简单，双指针，就不细讲了，前面刷数组部分题目时也讲过双指针

```java
//344.反转字符串
public class LeetCode344 {
    public void reverseString(char[] s) {
        //双指针法
        int left = 0;
        int right = s.length - 1;
        while (left < right) {
            char tmp = s[left];
            s[left] = s[right];
            s[right] = tmp;
            left++;
            right--;
        }
    }
}
```





## 2.反转字符串II

### 题目

[力扣题目链接](https://leetcode.cn/problems/reverse-string-ii/)

给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。

如果剩余字符少于 k 个，则将剩余字符全部反转。

如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。

示例:

输入: s = "abcdefg", k = 2
输出: "bacdfeg"





### 思路

通过字符串长度和k就可以计算出最少要反转的次数为：n=s.length/2k
在第i次反转中，left指针为(i-1)*2k，right指针为left+k-1
如果最后剩下的字符数小于k，那么反转所有剩余字符时的left指针为n*2k，right指针为s.length-1
如果最后剩下的字符数大于k，left指针为n*2k，right指针为left+k-1

资料中的代码和我的代码有很大不同，思路上没啥不同，如果想学习一下那种代码风格所以可以去看看，这里我先按我自己的来。



```java
//541.反转字符串II
public class LeetCode541 {
    public static void main(String[] args) {
        System.out.println(reverseStr("abcdefg", 2));
    }

    public static String reverseStr(String s, int k) {
        /**
         * 思路：
         * 通过字符串长度和k就可以计算出最少要反转的次数为：n=s.length/2k
         * 在第i次反转中，left指针为(i-1)*2k，right指针为left+k-1
         * 如果最后剩下的字符数小于k，那么反转所有剩余字符时的left指针为n*2k，right指针为s.length-1
         * 如果最后剩下的字符数大于k，left指针为n*2k，right指针为left+k-1
         */
        char[] chars = s.toCharArray();
        int n = s.length()/(2*k);
        for (int i = 1; i <= n; i++) {
            int left = (i-1)*2*k;
            int right = left+k-1;
            reverse(left,right,chars);
        }

        int leftChars = s.length()%(2*k);
        if(leftChars<k){
            int left = n*2*k;
            int right = s.length()-1;
            reverse(left,right,chars);
        }else{
            int left=n*2*k;
            int right=left+k-1;
            reverse(left,right,chars);
        }
//        StringBuilder sb = new StringBuilder();
//        sb.append(chars);
//        String result = sb.toString();
//        return new String(chars);
        return String.valueOf(chars);
    }

    public static void reverse(int left,int right,char[] chars){
        while(left<right){
            char tmp = chars[left];
            chars[left]=chars[right];
            chars[right]=tmp;
            left++;
            right--;
        }
    }
}
```







## 3.替换数字

### 题目

[卡码网题目链接](https://kamacoder.com/problempage.php?pid=1064)

给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。

例如，对于输入字符串 "a1b2c3"，函数应该将其转换为 "anumberbnumbercnumber"。

对于输入字符串 "a5b"，函数应该将其转换为 "anumberb"

输入：一个字符串 s,s 仅包含小写字母和数字字符。

输出：打印一个新的字符串，其中每个数字字符都被替换为了number

样例输入：a1b2c3

样例输出：anumberbnumbercnumber

数据范围：1 <= s.length < 10000。



### 思路

这题我一看，用正则表达式直接替换就是结果，但这样就没意思了，资料中给的思路对我来说是新的思路，如下

首先根据原字符串中数字的个数来扩容字符数组，每有一个数字，字符数组长度就扩容5个
接着采用双指针法，left指向原数组的最后一个字符，right指向扩容后的数组的最后一个位置
两指针同时从后往前遍历，如果left所指的元素为字母，就将该字母复制到right所指向的位置
如果left所指的元素为数字，就将right-5到right这块区域的内容改为number
然后更新right指针为right-6，left指针也向前移动一位



```java
import java.util.Scanner;

//替换数字
public class KamaCoder54 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String s = sc.nextLine();
        System.out.println(replaceNumber(s));
    }

    public static String replaceNumber_My(String s){
        //使用正则表达式很简单，但是学不到啥东西
        String result = s.replaceAll("\\d", "number");
        return result;
    }

    public static String replaceNumber(String s){
        //不使用正则表达式
        /**
         * 思路：
         * 首先根据原字符串中数字的个数来扩容字符数组，每有一个数字，字符数组长度就扩容5个
         * 接着采用双指针法，left指向原数组的最后一个字符，right指向扩容后的数组的最后一个位置
         * 两指针同时从后往前遍历，如果left所指的元素为字母，就将该字母复制到right所指向的位置
         * 如果left所指的元素为数字，就将right-5到right这块区域的内容改为number
         * 然后更新right指针为right-6，left指针也向前移动一位
         *
         */

        int count=0;
        //判断原字符串中数字的个数
        for (int i = 0; i < s.length(); i++) {
            if(Character.isDigit(s.charAt(i))){
                count++;
            }
        }
        //扩容字符数组
        char[] newChars = new char[s.length()+count*5];
        //将原数组的内容复制到新数组中
        System.arraycopy(s.toCharArray(),0,newChars,0,s.length());
        //采用双指针从后往前遍历
        int left = s.length()-1;
        int right = newChars.length-1;
        while(left<right){
            if(!Character.isDigit(newChars[left])){
                //如果left所指的字符不是数字，直接将该字符复制到right位置上
                newChars[right]=newChars[left];
                right--;
                left--;
            }else{
                //如果left所指的字符是数字，就将right-5到right这块区域的内容改为number
                newChars[right--]='r';
                newChars[right--]='e';
                newChars[right--]='b';
                newChars[right--]='m';
                newChars[right--]='u';
                newChars[right--]='n';
                left--;
            }
        }
        return String.valueOf(newChars);
    }

}
```









## 4.翻转字符串里的单词

### 题目

[力扣题目链接](https://leetcode.cn/problems/reverse-words-in-a-string/)

给定一个字符串，逐个翻转字符串中的每个单词。

示例 1：
输入: "the sky is blue"
输出: "blue is sky the"

示例 2：
输入: "  hello world!  "
输出: "world! hello"
解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。

示例 3：
输入: "a good  example"
输出: "example good a"
解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。



### 思路

不许使用库函数，要自己实现每个一方法。

整体思路：
首先移除字符串中多余的空格，多余的空格指的是字符串首尾的空格以及中间多出来的空格，分割单词的单个空格不算
然后将整个字符串反转，此时单词出现的顺序反转了，但同时单词内部字符出现的顺序也反转了
因此再将每个单词内部字符再反转回来，此时字符就仅仅只有单词出现的顺序反转了，而单词内部并没有反转



```java
import java.util.Arrays;

//151.反转字符串中的单词
public class LeetCode151 {
    public static void main(String[] args) {
        System.out.println(reverseWords("  hello world  "));
    }

    public static String reverseWords(String s){
        //不许用库函数
        /**
         * 整体思路：
         * 首先移除字符串中多余的空格，多余的空格指的是字符串首尾的空格以及中间多出来的空格，分割单词的单个空格不算
         * 然后将整个字符串反转，此时单词出现的顺序反转了，但同时单词内部字符出现的顺序也反转了
         * 因此再将每个单词内部字符再反转回来，此时字符就仅仅只有单词出现的顺序反转了，而单词内部并没有反转
         */

        //移除多余空格
        StringBuilder sb = removeSpace(s);
        //反转整个字符串
        reverseString(sb,0,sb.length()-1);
        //最后反转每个单词
        reverseSingleWord(sb);
        return  sb.toString();
    }

    public static StringBuilder removeSpace(String s){
        //这个移除多余空格的思路也要好好学一学
        StringBuilder sb = new StringBuilder();
        int left=0;
        int right=s.length()-1;
        //首先移除首尾多余的空格
        while(s.charAt(left)==' ') left++;
        while(s.charAt(right)==' ') right--;
        //接着移除中间多余的空格
        while(left<=right){
            if(s.charAt(left)!=' '||sb.charAt(sb.length()-1)!=' '){
                sb.append(s.charAt(left));
            }
            left++;
        }
        return sb;
    }

    public static void reverseString(StringBuilder sb,int left,int right){
        //反转指定区间的字符串
        //双指针反转
        while(left<right){
            char tmp = sb.charAt(left);
            sb.setCharAt(left,sb.charAt(right));
            sb.setCharAt(right,tmp);
            left++;
            right--;
        }
    }

    public static void reverseSingleWord(StringBuilder sb){
        //反转每个单词
        //start代表每个单词的起始位置
        int start=0;
        //end代表每个单词的结束位置
        int end = start+1;
        //n代表字符串的长度
        int n =sb.length();
        while (start<n){
            //寻找每个单词的结束位置
            while (end<n&&sb.charAt(end)!=' '){
                end++;
            }
            reverseString(sb,start,end-1);
            start=end+1;
            end=start+1;
        }
    }


    public static String reverseWords_My(String s) {
        //用库函数没啥意思
        s=s.trim();
        String[] words = s.split("\\s+");
        System.out.println(Arrays.toString(words));
        //双指针
        int left = 0;
        int right = words.length-1;
        while(left<right){
            String tmp = words[left];
            words[left]=words[right];
            words[right]=tmp;
            left++;
            right--;
        }
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < words.length; i++) {
            sb.append(words[i]);
            if(i!=words.length-1){
                sb.append(" ");
            }
        }
        return sb.toString();
    }

}
```





## 5.右旋字符串

### 题目

[卡码网题目链接](https://kamacoder.com/problempage.php?pid=1065)

字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。

例如，对于输入字符串 "abcdefg" 和整数 2，函数应该将其转换为 "fgabcde"。

输入：输入共包含两行，第一行为一个正整数 k，代表右旋转的位数。第二行为字符串 s，代表需要旋转的字符串。

输出：输出共一行，为进行了右旋转操作后的字符串。

样例输入：

```text
2
abcdefg 
```

样例输出：

```text
fgabcde
```

数据范围：1 <= k < 10000, 1 <= s.length < 10000;



### 思路

学到的新思路：
字符串的”负负得正“的思想，即：翻转的字符再翻转一遍就会恢复原样
在这里，我们根据k的值将字符串分成两部分，后面k个字符为一部分，剩下的字符为另一个部分
此时，这道题的思路就变得和`LeetCode151翻转字符串里的单词`很像，我们可以把第一个部分看成一个单词，另一个部分也看成一个单词
所以，先将字符串整体翻转，然后对每一个部分的字符串进行翻转



```java
package algorithm;

import java.util.Scanner;

//右旋字符串
public class KamaCoder55 {

    public static void main(String[] args) {
        /**
         * 学到的新思路：
         * 字符串的”负负得正“的思想，即：翻转的字符再翻转一遍就会恢复原样
         * 在这里，我们根据k的值将字符串分成两部分，后面k个字符为一部分，剩下的字符为另一个部分
         * 此时，这道题的思路就变得和LeetCode151翻转字符串里的单词很像，我们可以把第一个部分看成一个单词，另一个部分也看成一个单词
         * 所以，先将字符串整体翻转，然后对每一个部分的字符串进行翻转
         */
        Scanner sc = new Scanner(System.in);
        int k =sc.nextInt();
        String s = sc.next();
        StringBuilder sb = new StringBuilder(s);
        //先翻转整个字符串
        reverseSinglePart(sb,0,sb.length()-1);
        //再翻转每一个部分
        reverseSinglePart(sb,0,k-1);
        reverseSinglePart(sb,k,sb.length()-1);
        System.out.println(sb);

    }
    public static void reverseSinglePart(StringBuilder sb,int start,int end){
        //翻转部分字符串，范围为[start,end]，包前包后
        while (start<end){
            char tmp = sb.charAt(start);
            sb.setCharAt(start,sb.charAt(end));
            sb.setCharAt(end,tmp);
            start++;
            end--;
        }

    }


    public static void main_my(String[] args) {
        /**
         * 我的思路：
         * 约瑟夫回环，新建一个索引index指向倒数第k个字符
         * 输出索引指向的字符，然后index=（index+1）%字符串长度，一直循环输出索引指向的字符
         * 直到索引回到最开始的位置
         */
        Scanner sc = new Scanner(System.in);
        int k = sc.nextInt();
        String s = sc.next();
        int init = s.length()-k;
        int index = init;
        int len = s.length();
        StringBuilder sb = new StringBuilder();
        sb.append(s.charAt(index));
        index=(index+1)%len;
        while (index!=init){
            sb.append(s.charAt(index));
            index=(index+1)%len;
        }
        System.out.println(sb.toString());
    }
}
```





## 6.实现strStr()

### 题目

[力扣题目链接](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)

实现 strStr() 函数。

给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。

示例 1: 输入: haystack = "hello", needle = "ll" 输出: 2

示例 2: 输入: haystack = "aaaaa", needle = "bba" 输出: -1

说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。



### 思路

KMP算法，这个算法很抽象，得花点时间来理解，这里直接复制资料的讲解

KMP的经典思想就是:**当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。**

本篇将以如下顺序来讲解KMP，

- 什么是KMP
- KMP有什么用
- 什么是前缀表
- 为什么一定要用前缀表
- 如何计算前缀表
- 前缀表与next数组
- 使用next数组来匹配
- 时间复杂度分析
- 构造next数组
- 使用next数组来做匹配
- 前缀表统一减一 C++代码实现
- 前缀表（不减一）C++实现
- 总结

读完本篇可以顺便把leetcode上28.实现strStr()题目做了。

### 什么是KMP

说到KMP，先说一下KMP这个名字是怎么来的，为什么叫做KMP呢。

因为是由这三位学者发明的：Knuth，Morris和Pratt，所以取了三位学者名字的首字母。所以叫做KMP

### KMP有什么用

KMP主要应用在字符串匹配上。

KMP的主要思想是**当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。**

所以如何记录已经匹配的文本内容，是KMP的重点，也是next数组肩负的重任。

其实KMP的代码不好理解，一些同学甚至直接把KMP代码的模板背下来。

没有彻底搞懂，懵懵懂懂就把代码背下来太容易忘了。

不仅面试的时候可能写不出来，如果面试官问：**next数组里的数字表示的是什么，为什么这么表示？**

估计大多数候选人都是懵逼的。

下面Carl就带大家把KMP的精髓，next数组弄清楚。

### 什么是前缀表

写过KMP的同学，一定都写过next数组，那么这个next数组究竟是个啥呢？

next数组就是一个前缀表（prefix table）。

前缀表有什么作用呢？

**前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。**

为了清楚地了解前缀表的来历，我们来举一个例子：

要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。

请记住文本串和模式串的作用，对于理解下文很重要，要不然容易看懵。所以说三遍：

要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。

要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。

要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。

如动画所示：

![KMP详解1](./pictures/KMP精讲1.gif)

动画里，我特意把 子串`aa` 标记上了，这是有原因的，大家先注意一下，后面还会说到。

可以看出，文本串中第六个字符b 和 模式串的第六个字符f，不匹配了。如果暴力匹配，发现不匹配，此时就要从头匹配了。

但如果使用前缀表，就不会从头匹配，而是从上次已经匹配的内容开始匹配，找到了模式串中第三个字符b继续开始匹配。

此时就要问了**前缀表是如何记录的呢？**

首先要知道前缀表的任务是当前位置匹配失败，找到之前已经匹配上的位置，再重新匹配，此也意味着在某个字符失配时，前缀表会告诉你下一步匹配中，模式串应该跳到哪个位置。

那么什么是前缀表：**记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。**

### 最长公共前后缀

文章中字符串的**前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串**。

**后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串**。

**正确理解什么是前缀什么是后缀很重要**!

那么网上清一色都说 “kmp 最长公共前后缀” 又是什么回事呢？

我查了一遍 算法导论 和 算法4里KMP的章节，都没有提到 “最长公共前后缀”这个词，也不知道从哪里来了，我理解是用“最长相等前后缀” 更准确一些。

**因为前缀表要求的就是相同前后缀的长度。**

而最长公共前后缀里面的“公共”，更像是说前缀和后缀公共的长度。这其实并不是前缀表所需要的。

所以字符串a的最长相等前后缀为0。 字符串aa的最长相等前后缀为1。 字符串aaa的最长相等前后缀为2。 等等.....。

### 为什么一定要用前缀表

这就是前缀表，那为啥就能告诉我们 上次匹配的位置，并跳过去呢？

回顾一下，刚刚匹配的过程在下标5的地方遇到不匹配，模式串是指向f，如图： ![KMP精讲1](./pictures/KMP精讲1.png)

然后就找到了下标2，指向b，继续匹配：如图： ![KMP精讲2](./pictures/KMP精讲2.png)

以下这句话，对于理解为什么使用前缀表可以告诉我们匹配失败之后跳到哪里重新匹配 非常重要！

**下标5之前这部分的字符串（也就是字符串aabaa）的最长相等的前缀 和 后缀字符串是 子字符串aa ，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面重新匹配就可以了。**

所以前缀表具有告诉我们当前位置匹配失败，跳到之前已经匹配过的地方的能力。

**很多介绍KMP的文章或者视频并没有把为什么要用前缀表？这个问题说清楚，而是直接默认使用前缀表。**

### 如何计算前缀表

接下来就要说一说怎么计算前缀表。

如图：

![KMP精讲5](./pictures/KMP精讲5.png)

长度为前1个字符的子串`a`，最长相同前后缀的长度为0。（注意字符串的**前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串**；**后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串**。）

![KMP精讲6](./pictures/KMP精讲6.png)

长度为前2个字符的子串`aa`，最长相同前后缀的长度为1。

![KMP精讲7](./pictures/KMP精讲7.png)

长度为前3个字符的子串`aab`，最长相同前后缀的长度为0。

以此类推： 长度为前4个字符的子串`aaba`，最长相同前后缀的长度为1。 长度为前5个字符的子串`aabaa`，最长相同前后缀的长度为2。 长度为前6个字符的子串`aabaaf`，最长相同前后缀的长度为0。

那么把求得的最长相同前后缀的长度就是对应前缀表的元素，如图： ![KMP精讲8](./pictures/KMP精讲8.png)

可以看出模式串与前缀表对应位置的数字表示的就是：**下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。**

再来看一下如何利用 前缀表找到 当字符不匹配的时候应该指针应该移动的位置。如动画所示：

![KMP精讲2](./pictures/KMP精讲2.gif)

找到的不匹配的位置， 那么此时我们要看它的前一个字符的前缀表的数值是多少。

为什么要前一个字符的前缀表的数值呢，因为要找前面字符串的最长相同的前缀和后缀。

所以要看前一位的 前缀表的数值。

前一个字符的前缀表的数值是2， 所以把下标移动到下标2的位置继续比配。 可以再反复看一下上面的动画。

最后就在文本串中找到了和模式串匹配的子串了。

### 前缀表与next数组

很多KMP算法的实现都是使用next数组来做回退操作，那么next数组与前缀表有什么关系呢？

next数组就可以是前缀表，但是很多实现都是把前缀表统一减一（右移一位，初始位置为-1）之后作为next数组。

为什么这么做呢，其实也是很多文章视频没有解释清楚的地方。

其实**这并不涉及到KMP的原理，而是具体实现，next数组既可以就是前缀表，也可以是前缀表统一减一（右移一位，初始位置为-1）。**

后面我会提供两种不同的实现代码，大家就明白了。

### 使用next数组来匹配

**以下我们以前缀表统一减一之后的next数组来做演示**。

有了next数组，就可以根据next数组来 匹配文本串s，和模式串t了。

注意next数组是新前缀表（旧前缀表统一减一了）。

匹配过程动画如下：

![KMP精讲4](./pictures/KMP精讲4.gif)

### 时间复杂度分析

其中n为文本串长度，m为模式串长度，因为在匹配的过程中，根据前缀表不断调整匹配的位置，可以看出匹配的过程是O(n)，之前还要单独生成next数组，时间复杂度是O(m)。所以整个KMP算法的时间复杂度是O(n+m)的。

暴力的解法显而易见是O(n × m)，所以**KMP在字符串匹配中极大地提高了搜索的效率。**

为了和力扣题目28.实现strStr保持一致，方便大家理解，以下文章统称haystack为文本串, needle为模式串。

都知道使用KMP算法，一定要构造next数组。

### 构造next数组

我们定义一个函数getNext来构建next数组，函数参数为指向next数组的指针，和一个字符串。 代码如下：

```text
void getNext(int* next, const string& s)
```

**构造next数组其实就是计算模式串s，前缀表的过程。** 主要有如下三步：

1. 初始化
2. 处理前后缀不相同的情况
3. 处理前后缀相同的情况

接下来我们详解一下。

1. 初始化：

定义两个指针i和j，j指向前缀末尾位置，i指向后缀末尾位置。

然后还要对next数组进行初始化赋值，如下：

```cpp
int j = -1;
next[0] = j;
```

j 为什么要初始化为 -1呢，因为之前说过 前缀表要统一减一的操作仅仅是其中的一种实现，我们这里选择j初始化为-1，下文我还会给出j不初始化为-1的实现代码。

next[i] 表示 i（包括i）之前最长相等的前后缀长度（其实就是j）

所以初始化next[0] = j 。

1. 处理前后缀不相同的情况

因为j初始化为-1，那么i就从1开始，进行s[i] 与 s[j+1]的比较。

所以遍历模式串s的循环下标i 要从 1开始，代码如下：

```cpp
for (int i = 1; i < s.size(); i++) {
```

如果 s[i] 与 s[j+1]不相同，也就是遇到 前后缀末尾不相同的情况，就要向前回退。

怎么回退呢？

next[j]就是记录着j（包括j）之前的子串的相同前后缀的长度。

那么 s[i] 与 s[j+1] 不相同，就要找 j+1前一个元素在next数组里的值（就是next[j]）。

所以，处理前后缀不相同的情况代码如下：

```cpp
while (j >= 0 && s[i] != s[j + 1]) { // 前后缀不相同了
    j = next[j]; // 向前回退
}
```

1. 处理前后缀相同的情况

如果 s[i] 与 s[j + 1] 相同，那么就同时向后移动i 和j 说明找到了相同的前后缀，同时还要将j（前缀的长度）赋给next[i], 因为next[i]要记录相同前后缀的长度。

代码如下：

```text
if (s[i] == s[j + 1]) { // 找到相同的前后缀
    j++;
}
next[i] = j;
```

最后整体构建next数组的函数代码如下：

```cpp
void getNext(int* next, const string& s){
    int j = -1;
    next[0] = j;
    for(int i = 1; i < s.size(); i++) { // 注意i从1开始
        while (j >= 0 && s[i] != s[j + 1]) { // 前后缀不相同了
            j = next[j]; // 向前回退
        }
        if (s[i] == s[j + 1]) { // 找到相同的前后缀
            j++;
        }
        next[i] = j; // 将j（前缀的长度）赋给next[i]
    }
}
```

代码构造next数组的逻辑流程动画如下：

![KMP精讲3](./pictures/KMP精讲3.gif)

得到了next数组之后，就要用这个来做匹配了。

### 使用next数组来做匹配

在文本串s里 找是否出现过模式串t。

定义两个下标j 指向模式串起始位置，i指向文本串起始位置。

那么j初始值依然为-1，为什么呢？ **依然因为next数组里记录的起始位置为-1。**

i就从0开始，遍历文本串，代码如下：

```cpp
for (int i = 0; i < s.size(); i++) 
```

接下来就是 s[i] 与 t[j + 1] （因为j从-1开始的） 进行比较。

如果 s[i] 与 t[j + 1] 不相同，j就要从next数组里寻找下一个匹配的位置。

代码如下：

```cpp
while(j >= 0 && s[i] != t[j + 1]) {
    j = next[j];
}
```

如果 s[i] 与 t[j + 1] 相同，那么i 和 j 同时向后移动， 代码如下：

```cpp
if (s[i] == t[j + 1]) {
    j++; // i的增加在for循环里
}
```

如何判断在文本串s里出现了模式串t呢，如果j指向了模式串t的末尾，那么就说明模式串t完全匹配文本串s里的某个子串了。

本题要在文本串字符串中找出模式串出现的第一个位置 (从0开始)，所以返回当前在文本串匹配模式串的位置i 减去 模式串的长度，就是文本串字符串中出现模式串的第一个位置。

代码如下：

```cpp
if (j == (t.size() - 1) ) {
    return (i - t.size() + 1);
}
```

那么使用next数组，用模式串匹配文本串的整体代码如下：

```cpp
int j = -1; // 因为next数组里记录的起始位置为-1
for (int i = 0; i < s.size(); i++) { // 注意i就从0开始
    while(j >= 0 && s[i] != t[j + 1]) { // 不匹配
        j = next[j]; // j 寻找之前匹配的位置
    }
    if (s[i] == t[j + 1]) { // 匹配，j和i同时向后移动
        j++; // i的增加在for循环里
    }
    if (j == (t.size() - 1) ) { // 文本串s里出现了模式串t
        return (i - t.size() + 1);
    }
}
```

此时所有逻辑的代码都已经写出来了，力扣 28.实现strStr 题目的整体代码如下：

### 前缀表统一减一 C++代码实现

```cpp
class Solution {
public:
    void getNext(int* next, const string& s) {
        int j = -1;
        next[0] = j;
        for(int i = 1; i < s.size(); i++) { // 注意i从1开始
            while (j >= 0 && s[i] != s[j + 1]) { // 前后缀不相同了
                j = next[j]; // 向前回退
            }
            if (s[i] == s[j + 1]) { // 找到相同的前后缀
                j++;
            }
            next[i] = j; // 将j（前缀的长度）赋给next[i]
        }
    }
    int strStr(string haystack, string needle) {
        if (needle.size() == 0) {
            return 0;
        }
		vector<int> next(needle.size());
		getNext(&next[0], needle);
        int j = -1; // // 因为next数组里记录的起始位置为-1
        for (int i = 0; i < haystack.size(); i++) { // 注意i就从0开始
            while(j >= 0 && haystack[i] != needle[j + 1]) { // 不匹配
                j = next[j]; // j 寻找之前匹配的位置
            }
            if (haystack[i] == needle[j + 1]) { // 匹配，j和i同时向后移动
                j++; // i的增加在for循环里
            }
            if (j == (needle.size() - 1) ) { // 文本串s里出现了模式串t
                return (i - needle.size() + 1);
            }
        }
        return -1;
    }
};
```

- 时间复杂度: O(n + m)
- 空间复杂度: O(m), 只需要保存字符串needle的前缀表

### 前缀表（不减一）C++实现

那么前缀表就不减一了，也不右移的，到底行不行呢？

**行！**

我之前说过，这仅仅是KMP算法实现上的问题，如果就直接使用前缀表可以换一种回退方式，找j=next[j-1] 来进行回退。

主要就是j=next[x]这一步最为关键！

我给出的getNext的实现为：（前缀表统一减一）

```cpp
void getNext(int* next, const string& s) {
    int j = -1;
    next[0] = j;
    for(int i = 1; i < s.size(); i++) { // 注意i从1开始
        while (j >= 0 && s[i] != s[j + 1]) { // 前后缀不相同了
            j = next[j]; // 向前回退
        }
        if (s[i] == s[j + 1]) { // 找到相同的前后缀
            j++;
        }
        next[i] = j; // 将j（前缀的长度）赋给next[i]
    }
}
```

此时如果输入的模式串为aabaaf，对应的next为-1 0 -1 0 1 -1。

这里j和next[0]初始化为-1，整个next数组是以 前缀表减一之后的效果来构建的。

那么前缀表不减一来构建next数组，代码如下：

```cpp
    void getNext(int* next, const string& s) {
        int j = 0;
        next[0] = 0;
        for(int i = 1; i < s.size(); i++) {
            while (j > 0 && s[i] != s[j]) { // j要保证大于0，因为下面有取j-1作为数组下标的操作
                j = next[j - 1]; // 注意这里，是要找前一位的对应的回退位置了
            }
            if (s[i] == s[j]) {
                j++;
            }
            next[i] = j;
        }
    }
```

此时如果输入的模式串为aabaaf，对应的next为 0 1 0 1 2 0，（其实这就是前缀表的数值了）。

那么用这样的next数组也可以用来做匹配，代码要有所改动。

实现代码如下：

```cpp
class Solution {
public:
    void getNext(int* next, const string& s) {
        int j = 0;
        next[0] = 0;
        for(int i = 1; i < s.size(); i++) {
            while (j > 0 && s[i] != s[j]) {
                j = next[j - 1];
            }
            if (s[i] == s[j]) {
                j++;
            }
            next[i] = j;
        }
    }
    int strStr(string haystack, string needle) {
        if (needle.size() == 0) {
            return 0;
        }
        vector<int> next(needle.size());
        getNext(&next[0], needle);
        int j = 0;
        for (int i = 0; i < haystack.size(); i++) {
            while(j > 0 && haystack[i] != needle[j]) {
                j = next[j - 1];
            }
            if (haystack[i] == needle[j]) {
                j++;
            }
            if (j == needle.size() ) {
                return (i - needle.size() + 1);
            }
        }
        return -1;
    }
};
```

- 时间复杂度: O(n + m)
- 空间复杂度: O(m)





### Java代码

```java
/**
 * 28.找出字符串中第一个匹配项的下标
 */
public class LeetCode28 {
    public static void main(String[] args) {
        System.out.println(strStr("hello", "ll"));
    }


    public static int strStr(String haystack, String needle) {
        /**
         * 正确思路：KMP算法
         * 这个KMP算法挺抽象的，具体的算法讲解见笔记或资料。
         * 首先先构造needle的next数组，next数组就是模式串needle的每个字符对应的最长公共前后缀长度
         * 构造完next数组后就可以让haystack与needle进行比对
         * 定义两个指针，i指向haystack，j指向needle
         * 如果i，j指向的字符相同，i++ j++
         * 如果不同就根据j对应的next数组的值，让j回退到next数组指向的位置
         * 就这样一直比对
         * 直到j指向needle的末尾，说明成功匹配
         * 或者i指向haystack的末尾，但如果此时j没有指向needle的末尾，说明没有找到
         */

        //构造next数组，这是难点，next数组表示的就是当前位置的前面字符串的最长公共前后缀
        int[] next = new int[needle.length()];
        //初始化next数组
        next[0] = 0;          //开头第一个字符的最长公共前后缀长度为0
        int j = 0;            //j表示前缀字符串的末尾
        //i表示后缀字符串的末尾
        for (int i = 1; i < needle.length(); i++) {
            while (j > 0 && needle.charAt(i) != needle.charAt(j)) {
                //如果前后缀不匹配就回退
                j = next[j-1];
            }
            if (needle.charAt(i) == needle.charAt(j)) {
                //如果匹配成功，两个指针同时向前移动
                j++;
            }
            next[i] = j;
        }

        //构造完next数组后就可以使用next数组来匹配文本串haystack和模式串needle了
        //i指向haystack，j指向needle

        j = 0;
        for (int i = 0; i <haystack.length(); i++) {
            while(j>0&&haystack.charAt(i)!=needle.charAt(j)){
                j=next[j-1];
            }
            if(haystack.charAt(i)==needle.charAt(j)){
                j++;
            }
            if(j>=needle.length()){
                return i-needle.length()+1;
            }

        }
        return -1;
    }


    public int strStr_My(String haystack, String needle) {
        /**
         * 我的思路：双指针，该思路无法全部通过
         * 一个指针h指向haystack，另一个指针n指向needle
         * 如果h和n指向的字符相同，则h和n同时移动，否则n重新指向needle的开头
         * 直到h超出haystack的长度或n超出needle的长度
         * 如果h超出haystack的长度的同时n没有超出needle的长度说明haystack中不存在needle，返回-1
         * 如果n超出needle的长度说明haystack中存在needle，返回(h-needle的长度)。
         *
         */

        int h = 0;
        int n = 0;
        while (h < haystack.length() && n < needle.length()) {
            if (haystack.charAt(h) == needle.charAt(n)) {
                h++;
                n++;
            } else {
                h++;
                n = 0;
            }
        }
        if (h >= haystack.length() && n < needle.length()) {
            return -1;
        }

        return h - needle.length();
    }
}
```





## 7.重复的子字符串

### 题目

[力扣题目链接](https://leetcode.cn/problems/repeated-substring-pattern/)

给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。

示例 1:

- 输入: "abab"
- 输出: True
- 解释: 可由子字符串 "ab" 重复两次构成。

示例 2:

- 输入: "aba"
- 输出: False

示例 3:

- 输入: "abcabcabcabc"
- 输出: True
- 解释: 可由子字符串 "abc" 重复四次构成。 (或者子字符串 "abcabc" 重复两次构成。）



### 思路

这题的思路也略显复杂（很有收获），直接贴资料的思路解释。

暴力的解法， 就是一个for循环获取 子串的终止位置， 然后判断子串是否能重复构成字符串，又嵌套一个for循环，所以是O(n^2)的时间复杂度。

有的同学可以想，怎么一个for循环就可以获取子串吗？ 至少得一个for获取子串起始位置，一个for获取子串结束位置吧。

其实我们只需要判断，以第一个字母为开始的子串就可以，所以一个for循环获取子串的终止位置就行了。 而且遍历的时候 都不用遍历结束，只需要遍历到中间位置，因为子串结束位置大于中间位置的话，一定不能重复组成字符串。

暴力的解法，这里就不详细讲解了。

主要讲一讲移动匹配 和 KMP两种方法。

### [#](https://programmercarl.com/0459.重复的子字符串.html#移动匹配)移动匹配

当一个字符串s：abcabc，内部由重复的子串组成，那么这个字符串的结构一定是这样的：

![图一](./pictures/20220728104518.png)

也就是由前后相同的子串组成。

那么既然前面有相同的子串，后面有相同的子串，用 s + s，这样组成的字符串中，后面的子串做前串，前面的子串做后串，就一定还能组成一个s，如图：

![图二](./pictures/20220728104931.png)

当然，我们在判断 s + s 拼接的字符串里是否出现一个s的的时候，**要刨除 s + s 的首字符和尾字符**，这样避免在s+s中搜索出原来的s，我们要搜索的是中间拼接出来的s。

以上证明的充分性，接下来证明必要性：

如果有一个字符串s，在 s + s 拼接后， 不算首尾字符，如果能凑成s字符串，说明s 一定是重复子串组成。

如图，字符串s，图中数字为数组下标，在 s + s 拼接后， 不算首尾字符，中间凑成s字符串。 （图中数字为数组下标）

![img](./pictures/20240910115555.png)

图中，因为中间拼接成了s，根据红色框 可以知道 s[4] = s[0]， s[5] = s[1]， s[0] = s[2], s[1] = s[3] s[2] = s[4] ,s[3] = s[5]

![img](./pictures/20240910115819.png)

以上相等关系我们串联一下：

s[4] = s[0] = s[2]

s[5] = s[1] = s[3]

即：s[4],s[5] = s[0],s[1] = s[2],s[3]

**说明这个字符串，是由 两个字符 s[0] 和 s[1] 重复组成的**！

这里可以有录友想，凭什么就是这样组成的s呢，我换一个方式组成s 行不行，如图：

![img](./pictures/20240910120751.png)

s[3] = s[0]，s[4] = s[1] ，s[5] = s[2]，s[0] = s[3]，s[1] = s[4]，s[2] = s[5]

以上相等关系串联：

s[3] = s[0]

s[1] = s[4]

s[2] = s[5]

s[0] s[1] s[2] = s[3] s[4] s[5]

和以上推导过程一样，最后可以推导出，这个字符串是由 s[0] ，s[1] ，s[2] 重复组成。

如果是这样的呢，如图：

![img](./pictures/20240910121236.png)

s[1] = s[0]，s[2] = s[1] ，s[3] = s[2]，s[4] = s[3]，s[5] = s[4]，s[0] = s[5]

以上相等关系串联

s[0] = s[1] = s[2] = s[3] = s[4] = s[5]

最后可以推导出，这个字符串是由 s[0] 重复组成。

以上 充分和必要性都证明了，所以判断字符串s是否由重复子串组成，只要两个s拼接在一起，里面还出现一个s的话，就说明是由重复子串组成。

代码如下：

```cpp
class Solution {
public:
    bool repeatedSubstringPattern(string s) {
        string t = s + s;
        t.erase(t.begin()); t.erase(t.end() - 1); // 掐头去尾
        if (t.find(s) != std::string::npos) return true; // r
        return false;
    }
};
```

1
2
3
4
5
6
7
8
9

- 时间复杂度: O(n)
- 空间复杂度: O(1)

不过这种解法还有一个问题，就是 我们最终还是要判断 一个字符串（s + s）是否出现过 s 的过程，大家可能直接用contains，find 之类的库函数， 却忽略了实现这些函数的时间复杂度（暴力解法是m * n，一般库函数实现为 O(m + n)）。

如果我们做过 [28.实现strStr (opens new window)](https://programmercarl.com/0028.实现strStr.html)题目的话，其实就知道，**实现一个 高效的算法来判断 一个字符串中是否出现另一个字符串是很复杂的**，这里就涉及到了KMP算法。

### [#](https://programmercarl.com/0459.重复的子字符串.html#kmp)KMP

#### [#](https://programmercarl.com/0459.重复的子字符串.html#为什么会使用kmp)为什么会使用KMP

以下使用KMP方式讲解，强烈建议大家先把以下两个视频看了，理解KMP算法，再来看下面讲解，否则会很懵。

- [视频讲解版：帮你把KMP算法学个通透！（理论篇）](https://www.bilibili.com/video/BV1PD4y1o7nd/)
- [视频讲解版：帮你把KMP算法学个通透！（求next数组代码篇）](https://www.bilibili.com/video/BV1M5411j7Xx)
- [文字讲解版：KMP算法(opens new window)](https://programmercarl.com/0028.实现strStr.html)

在一个串中查找是否出现过另一个串，这是KMP的看家本领。那么寻找重复子串怎么也涉及到KMP算法了呢？

KMP算法中next数组为什么遇到字符不匹配的时候可以找到上一个匹配过的位置继续匹配，靠的是有计算好的前缀表。

前缀表里，统计了各个位置为终点字符串的最长相同前后缀的长度。

那么 最长相同前后缀和重复子串的关系又有什么关系呢。

可能很多录友又忘了 前缀和后缀的定义，再回顾一下：

- 前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串；
- 后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串

#### [#](https://programmercarl.com/0459.重复的子字符串.html#充分性证明)充分性证明

如果一个字符串s是由重复子串组成，那么 最长相等前后缀不包含的子串一定是字符串s的最小重复子串。

如果s 是由最小重复子串p组成，即 s = n * p

那么相同前后缀可以是这样：

![img](./pictures/20240913110257.png)

也可以是这样：

![img](./pictures/20240913110316.png)

最长的相等前后缀，也就是这样：

![img](./pictures/20240913110841.png)

这里有录友就想：如果字符串s 是由最小重复子串p组成，最长相等前后缀就不能更长一些？ 例如这样：

![img](./pictures/20240913114348.png)

如果这样的话，因为前后缀要相同，所以 p2 = p1，p3 = p2，如图：

![img](./pictures/20240913114818.png)

p2 = p1，p3 = p2 即： p1 = p2 = p3

说明 p = p1 * 3。

这样p 就不是最小重复子串了，不符合我们定义的条件。

所以，**如果这个字符串s是由重复子串组成，那么最长相等前后缀不包含的子串是字符串s的最小重复子串**。

#### [#](https://programmercarl.com/0459.重复的子字符串.html#必要性证明)必要性证明

以上是充分性证明，以下是必要性证明：

**如果 最长相等前后缀不包含的子串是字符串s的最小重复子串， 那么字符串s一定由重复子串组成吗**？

最长相等前后缀不包含的子串已经是字符串s的最小重复子串，那么字符串s一定由重复子串组成，这个不需要证明了。

关键是要证明：最长相等前后缀不包含的子串什么时候才是字符串s的最小重复子串呢。

情况一， 最长相等前后缀不包含的子串的长度 比 字符串s的一半的长度还大，那一定不是字符串s的重复子串，如图：

![img](./pictures/20240911110236.png)

图中：前后缀不包含的子串的长度 大于 字符串s的长度的 二分之一

------

情况二，最长相等前后缀不包含的子串的长度 可以被 字符串s的长度整除，如图：

![img](./pictures/20240910174249.png)

步骤一：因为 这是相等的前缀和后缀，t[0] 与 k[0]相同， t[1] 与 k[1]相同，所以 s[0] 一定和 s[2]相同，s[1] 一定和 s[3]相同，即：，s[0]s[1]与s[2]s[3]相同 。

步骤二： 因为在同一个字符串位置，所以 t[2] 与 k[0]相同，t[3] 与 k[1]相同。

步骤三： 因为 这是相等的前缀和后缀，t[2] 与 k[2]相同 ，t[3]与k[3] 相同，所以，s[2]一定和s[4]相同，s[3]一定和s[5]相同，即：s[2]s[3] 与 s[4]s[5]相同。

步骤四：循环往复。

所以字符串s，s[0]s[1]与s[2]s[3]相同， s[2]s[3] 与 s[4]s[5]相同，s[4]s[5] 与 s[6]s[7] 相同。

可以推出，在由重复子串组成的字符串中，最长相等前后缀不包含的子串就是最小重复子串。

即 s[0]s[1] 是最小重复子串

以上推导中，录友可能想，你怎么知道 s[0] 和 s[1] 就不相同呢？ s[0] 为什么就不能是最小重复子串。

如果 s[0] 和 s[1] 也相同，同时 s[0]s[1]与s[2]s[3]相同，s[2]s[3] 与 s[4]s[5]相同，s[4]s[5] 与 s[6]s[7] 相同，那么这个字符串就是有一个字符构成的字符串。

那么它的最长相同前后缀，就不是上图中的前后缀，而是这样的的前后缀：

![img](./pictures/20240910175053.png)

录友可能再问，由一个字符组成的字符串，最长相等前后缀凭什么就是这样的。

有这种疑惑的录友，就是还不知道 最长相等前后缀 是怎么算的。

可以看这里：[KMP讲解 (opens new window)](https://programmercarl.com/0028.实现strStr.html)，再去回顾一下。

或者说，自己举个例子，`aaaaaa`，这个字符串，他的最长相等前后缀是什么？

同上以上推导，最长相等前后缀不包含的子串的长度只要被 字符串s的长度整除，最长相等前后缀不包含的子串一定是最小重复子串。

------

**情况三，最长相等前后缀不包含的子串的长度 不被 字符串s的长度整除得情况**，如图：

![img](./pictures/20240913115854.png)

步骤一：因为 这是相等的前缀和后缀，t[0] 与 k[0]相同， t[1] 与 k[1]相同，t[2] 与 k[2]相同。

所以 s[0] 与 s[3]相同，s[1] 与 s[4]相同，s[2] 与s[5]，即：，s[0]s[1]与s[2]s[3]相同 。

步骤二： 因为在同一个字符串位置，所以 t[3] 与 k[0]相同，t[4] 与 k[1]相同。

步骤三： 因为 这是相等的前缀和后缀，t[3] 与 k[3]相同 ，t[4]与k[5] 相同，所以，s[3]一定和s[6]相同，s[4]一定和s[7]相同，即：s[3]s[4] 与 s[6]s[7]相同。

以上推导，可以得出 s[0],s[1],s[2] 与 s[3],s[4],s[5] 相同，s[3]s[4] 与 s[6]s[7]相同。

那么 最长相等前后缀不包含的子串的长度 不被 字符串s的长度整除 ，最长相等前后缀不包含的子串就不是s的重复子串

------

充分条件：如果字符串s是由重复子串组成，那么 最长相等前后缀不包含的子串 一定是 s的最小重复子串。

必要条件：如果字符串s的最长相等前后缀不包含的子串 是 s最小重复子串，那么 s是由重复子串组成。

在必要条件，这个是 显而易见的，都已经假设 最长相等前后缀不包含的子串 是 s的最小重复子串了，那s必然是重复子串。

**关键是需要证明， 字符串s的最长相等前后缀不包含的子串 什么时候才是 s最小重复子串**。

同上我们证明了，当 最长相等前后缀不包含的子串的长度 可以被 字符串s的长度整除，那么不包含的子串 就是s的最小重复子串。





最后我根据思路自己写的代码如下

```java
//459.重复的子字符串
public class LeetCode459 {

    public static void main(String[] args) {
        System.out.println(repeatedSubstringPattern("ababac"));
    }
    public static boolean repeatedSubstringPattern(String s) {
        /**
         * 思路：
         * 一个字串如果是由重复字串组成，那么其最长相等前后缀所不包含的字串一定是重复的字串
         * 因此我们就去计算s的最长相等前后缀，此时不被包含的子串l与最长相等前后缀的关系有以下三种情况：
         * 1.不被包含的子串长度大于字符串s的一半，说明s不可能由重复字符串组成
         * 2.不被包含的子串长度刚好能够整除最长相等前后缀的长度，说明s由重复子串组成，且重复子串为不被包含的子串l
         * 3.不被包含的子串长度不能够整除最长相等前后缀的长度，说明s不是由重复子串组成。
         */

        int[] next = new int[s.length()];
        //获取字符串s的next数组
        getNext(next, s);
        //获取字符串s的最长前后缀长度
        //Arrays.sort(next);
        int max = next[s.length()-1];
        if((s.length()-max)>s.length()/2){
            //情况1
            return false;
        }else if(max%(s.length()-max)==0){
            //情况2
            return true;
        }
        //情况3
        return false;

    }

    public static void getNext(int[] next, String s) {
        //求s的next数组
        //初始化
        next[0] = 0;
        //j指向前缀末尾
        int j = 0;
        //i指向后缀末尾
        for (int i = 1; i < s.length(); i++) {
            while (j > 0 && s.charAt(i) != s.charAt(j)) {
                j=next[j-1];
            }
            if(s.charAt(j)==s.charAt(i)){
                j++;
            }
            next[i]=j;
        }
    }
}
```







# 栈与队列

## 2.用栈实现队列

### 题目

[力扣题目链接](https://leetcode.cn/problems/implement-queue-using-stacks/)

使用栈实现队列的下列操作：

push(x) -- 将一个元素放入队列的尾部。
pop() -- 从队列首部移除元素。
peek() -- 返回队列首部的元素。
empty() -- 返回队列是否为空。

示例:

```cpp
MyQueue queue = new MyQueue();
queue.push(1);
queue.push(2);
queue.peek();  // 返回 1
queue.pop();   // 返回 1
queue.empty(); // 返回 false
```

说明:

- 你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。
- 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
- 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。



### 思路

使用两个栈来模拟队列，一个栈作为输入栈`stackIn`，另一个栈作为输出栈`stackOut`。

队列的push操作就是向输入栈进行push操作

队列的pop和peek操作就是向输出栈进行pop和peek操作。如果输出栈为空需要将输入栈的数据倒入输出栈

队列的empty判断是否为空就是判断输入栈和输出栈是否为空，如果两个栈都为空说明队列为空

```java
//232.用栈实现队列
public class LeetCode232 {
    /**
     * 本题不涉及什么算法，主要要熟悉掌握队列和栈这个数据结构的使用
     */
}

class MyQueue {

    //输入栈
    private Stack<Integer> stackIn;
    //输出栈
    private Stack<Integer> stackOut;

    public MyQueue() {
        stackIn = new Stack<>();
        stackOut = new Stack<>();
    }

    public void push(int x) {
        stackIn.push(x);
    }

    public int pop() {
        //首先要确定输出栈是否为空，不为空才能弹出栈顶元素，为空需要将输入栈内容全部倒入输出栈
        dumpStackIn();
        return stackOut.pop();
    }

    public int peek() {
        dumpStackIn();
        return stackOut.peek();
    }

    public boolean empty() {
        return stackIn.isEmpty()&&stackOut.isEmpty();
    }

    private void dumpStackIn() {
        if(!stackOut.isEmpty()){
            return;
        }else{
            while(!stackIn.isEmpty()){
                stackOut.push(stackIn.pop());
            }
        }

    }
}
```





## 3.用队列实现栈

### 题目

[力扣题目链接](https://leetcode.cn/problems/implement-stack-using-queues/)

使用队列实现栈的下列操作：

- push(x) -- 元素 x 入栈
- pop() -- 移除栈顶元素
- top() -- 获取栈顶元素
- empty() -- 返回栈是否为空

注意:

- 你只能使用队列的基本操作-- 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。
- 你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。
- 你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。



### 思路

```
思路：
这里不能像用两个栈实现队列那样，一个作为输入队列，另一个作为输出队列
因为将一个队列中的元素倒到另一个队列中实际上元素的顺序还是没变。
这里的真正做法是将一个队列作为另一个队列的备份队列，比如队列1用来接收输入的元素
当栈要弹出栈顶的元素时，就先将队列1队列尾部前的所有元素备份到队列2，然后弹出队列1的尾部元素
弹出完成后就将队列2备份的元素重新放回队列1
```

```java
//225.用队列实现栈
public class LeetCode225 {
    public static void main(String[] args) {
        MyStack stack = new MyStack();
        stack.push(1);
        stack.push(2);
        stack.push(3);
        System.out.println(stack.top());
//        System.out.println(stack.pop());
//        System.out.println(stack.empty());
    }
}

class MyStack {
    /**
     * 思路：
     * 这里不能像用两个栈实现队列那样，一个作为输入队列，另一个作为输出队列
     * 因为将一个队列中的元素倒到另一个队列中实际上元素的顺序还是没变。
     * 这里的真正做法是将一个队列作为另一个队列的备份队列，比如队列1用来接收输入的元素
     * 当栈要弹出栈顶的元素时，就先将队列1队列尾部前的所有元素备份到队列2，然后弹出队列1的尾部元素
     * 弹出完成后就将队列2备份的元素重新放回队列1
     */

    //主队列
    private Queue<Integer> mainQueue;
    //备份队列
    private Queue<Integer> backupQueue;

    public MyStack() {
        mainQueue = new ArrayDeque<>();
        backupQueue= new ArrayDeque<>();
    }

    public void push(int x) {
        mainQueue.add(x);
    }

    public int pop() {
        backup();
        Integer poll = mainQueue.poll();
        load();
        return poll;
    }

    public int top() {
        backup();
        Integer peek = mainQueue.peek();
        load();
        return peek;
    }

    public boolean empty() {
        return mainQueue.isEmpty();
    }

    /**
     * 将主队列尾部前的元素备份到备份队列
     */
    private void backup(){
        int size = mainQueue.size();
        //这里踩了一个坑，由于mainQueue的长度每次循环后都会-1，因此如果在for循环中一直用size方法来获取长度，那这个长度就不是第一次获取的长度了，它会一直变小，导致中间有些元素没有被备份到备份队列中
//        for (int i = 0; i <mainQueue.size()-1; i++) {
        for (int i = 0; i < size-1; i++) {
            backupQueue.add(mainQueue.poll());
        }
    }

    /**
     * 将备份队列的元素重新加载到主队列
     */
    private void load(){
        Queue<Integer> tmp;
        if(mainQueue.isEmpty()){
            tmp = mainQueue;
            mainQueue = backupQueue;
            backupQueue = tmp;
        }else {
            backupQueue.add(mainQueue.poll());
            tmp = mainQueue;
            mainQueue = backupQueue;
            backupQueue = tmp;
        }
    }
}
```





## 4.有效的括号

### 题目

[力扣题目链接](https://leetcode.cn/problems/valid-parentheses/)

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。

有效字符串需满足：

- 左括号必须用相同类型的右括号闭合。
- 左括号必须以正确的顺序闭合。
- 注意空字符串可被认为是有效字符串。

示例 1:

- 输入: "()"
- 输出: true

示例 2:

- 输入: "()[]{}"
- 输出: true

示例 3:

- 输入: "(]"
- 输出: false

示例 4:

- 输入: "([)]"
- 输出: false

示例 5:

- 输入: "{[]}"
- 输出: true



### 思路

```
思路：栈的经典应用
遍历字符串s
如果是左括号就入栈
如果是普通字符就不管
如果是右括号就弹出栈顶元素
然后将栈顶元素与当前遍历到的元素比较
判断字符串无效有如下3种情况：
1.遍历过程中弹出的栈顶元素与当前元素不匹配，说明字符串无效
2.遍历过程中栈为空，说明右括号多余了，字符串无效
3.遍历完后，栈中还有元素，说明左括号多余了，字符串无效
判断字符串有效的情况：
遍历完字符串且栈元素为空

但是这里有个技巧
与原本不同，原本是遇到左括号就将其入栈，现在是遇到左括号就将其对应的右括号入栈
如：当前元素为'(' 就将')'入栈，当前元素为'['就将']'入栈
这样的好处就是在遍历到右括号时可以直接比较当前元素与栈顶元素是否相等，如果相等说明匹配成功，不相等说明匹配失败。
代码会好写很多
```

```java
//20.有效的括号
public class LeetCode20 {

    public boolean isValid(String s) {
        /**
         * 思路与下面的一样，但是这里是技巧版的
         * 与原本不同，原本是遇到左括号就将其入栈，现在是遇到左括号就将其对应的右括号入栈
         * 如：当前元素为'(' 就将')'入栈，当前元素为'['就将']'入栈
         * 这样的好处就是在遍历到右括号时可以直接比较当前元素与栈顶元素是否相等，如果相等说明匹配成功，不相等说明匹配失败。
         * 代码会好写很多
         */
        Stack<Character> stack = new Stack<>();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            //遍历到左括号时直接将其对应的右括号入栈
            if(c=='('){
                stack.push(')');
            }else if(c=='['){
                stack.push(']');
            }else if(c=='{'){
                stack.push('}');
            }

            //遍历到右括号时直接然其与栈顶元素比较
            if(c==')'||c==']'||c=='}'){
                if(stack.isEmpty()){
                    return false;
                }
                if(c!=stack.pop()){
                    return false;
                }
            }
        }
        return stack.isEmpty();
    }

    public boolean isValid_My(String s) {
        /**
         * 思路：栈的经典应用
         * 遍历字符串s
         * 如果是左括号就入栈
         * 如果是普通字符就不管
         * 如果是右括号就弹出栈顶元素
         * 然后将栈顶元素与当前遍历到的元素比较
         * 判断字符串无效有如下3种情况：
         * 1.遍历过程中弹出的栈顶元素与当前元素不匹配，说明字符串无效
         * 2.遍历过程中栈为空，说明右括号多余了，字符串无效
         * 3.遍历完后，栈中还有元素，说明左括号多余了，字符串无效
         *
         * 判断字符串有效的情况：
         * 遍历完字符串且栈元素为空
         */
        Stack<Character> stack = new Stack<>();
        for (int i = 0; i < s.length(); i++) {
            Character c = s.charAt(i);
            if (c == '(' || c == '[' || c == '{') {
                stack.push(c);
            } else if (c == ')' || c == ']' || c == '}') {
                if (stack.isEmpty()) {
                    return false;
                }
                Character element = stack.pop();
                if (c == ')' && element != '(') {
                    return false;
                } else if (c == ']' && element != '[') {
                    return false;
                } else if (c == '}' && element != '{') {
                    return false;
                }
            }
        }
        if (!stack.isEmpty()) {
            //栈不为空，说明左括号多余了
            return false;
        }
        return true;
    }

}
```





## 5.删除字符串中的所有相邻重复项

### 题目

[力扣题目链接](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)

给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。

在 S 上反复执行重复项删除操作，直到无法继续删除。

在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。

示例：

- 输入："abbaca"
- 输出："ca"
- 解释：例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。

提示：

- 1 <= S.length <= 20000
- S 仅由小写英文字母组成。



### 思路

```
思路：
遍历字符串s，每遍历一个字符就将字符存入栈
如果当前字符与栈顶字符相同，则弹出栈顶元素
当遍历完字符串后，栈内剩余所有字符就是最终结果

小技巧：这里可以直接用字符串作为栈，省去了转换字符串的操作，耗时从原来的110ms变为了33ms
```

```java
//1047.删除字符串中的所有相邻重复项
public class LeetCode1047 {
    public static void main(String[] args) {
        System.out.println(removeDuplicates("abbaca"));
    }

    //耗时33ms
    public static String removeDuplicates(String s) {
        /**
         * 思路与下面一致，不过这里可以直接用字符串作为栈，省去了转换字符串的操作
         */
        StringBuffer result = new StringBuffer();
        //top代表result的最后一个字符的索引
        int top = -1;
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if(result.length()<=0||result.charAt(top)!=c){
                result.append(c);
                top++;
            }else if(result.charAt(top)==c){
                result.deleteCharAt(top);
                top--;
            }
        }
        return result.toString();
    }

    //耗时110ms
    public static String removeDuplicates_My(String s) {
        /**
         * 思路：
         * 遍历字符串s，每遍历一个字符就将字符存入栈
         * 如果当前字符与栈顶字符相同，则弹出栈顶元素
         * 当遍历完字符串后，栈内剩余所有字符就是最终结果
         */
        Stack<Character> stack = new Stack<>();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (stack.isEmpty() || stack.peek() != c) {
                stack.add(c);
            } else if (stack.peek() == c) {
                stack.pop();
            }
        }
        StringBuffer sb = new StringBuffer();
        while (!stack.isEmpty()) {
            sb.insert(0, stack.pop());
        }
        return sb.toString();
    }
}
```





## 6.逆波兰表达式求值

### 题目

[力扣题目链接](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

根据 逆波兰表示法，求表达式的值。

有效的运算符包括 + , - , * , / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

说明：

整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。

示例 1：

- 输入: ["2", "1", "+", "3", " * "]
- 输出: 9
- 解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9

示例 2：

- 输入: ["4", "13", "5", "/", "+"]
- 输出: 6
- 解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6

示例 3：

- 输入: ["10", "6", "9", "3", "+", "-11", " * ", "/", " * ", "17", "+", "5", "+"]

- 输出: 22

- 解释:该算式转化为常见的中缀算术表达式为：

  ```text
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5       
  = ((10 * (6 / (12 * -11))) + 17) + 5       
  = ((10 * (6 / -132)) + 17) + 5     
  = ((10 * 0) + 17) + 5     
  = (0 + 17) + 5    
  = 17 + 5    
  = 22    
  ```

逆波兰表达式：是一种后缀表达式，所谓后缀就是指运算符写在后面。

平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。

该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。

逆波兰表达式主要有以下两个优点：

- 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。
- 适合用栈操作运算：遇到数字则入栈；遇到运算符则取出栈顶两个数字进行计算，并将结果压入栈中。



### 思路

```
思路：又一个栈的经典应用
遍历tokens中的每一个字符
如果当前字符为数字就直接压入栈中
如果当前字符为运算符，就从栈中弹出两个元素进行运算，然后将运算结果再压入栈中
当遍历完所有字符时，栈中剩下最后一个数字就是逆波兰表达式的结果
```

但是这里要特别学会使用Deque来代替Stack，因为Stack已经过时，Java官方也建议使用Deque来实现Stack，这部分内容也在`Java基础知识复习`笔记中更新，直接搜`Deque`



代码如下

```java
//150.逆波兰表达式求值
public class LeetCode150 {
    public static void main(String[] args) {
        System.out.println(evalRPN(new String[]{"4", "13", "5", "/", "+"}));
    }

    public static int evalRPN(String[] tokens) {
        /**
         * 思路：又一个栈的经典应用
         * 遍历tokens中的每一个字符
         * 如果当前字符为数字就直接压入栈中
         * 如果当前字符为运算符，就从栈中弹出两个元素进行运算，然后将运算结果再压入栈中
         * 当遍历完所有字符时，栈中剩下最后一个数字就是逆波兰表达式的结果
         */
        Deque<Integer> stack = new LinkedList<>();
        for (int i = 0; i < tokens.length; i++) {
            String exp3 = tokens[i];
            //注意先弹出的数字应该是作为减数和除数，后弹出的数组作为被减数和被除数
            if (exp3.equals("+")) {
                stack.push(stack.pop() + stack.pop());
            } else if (exp3.equals("-")) {
                stack.push(-stack.pop() + stack.pop());
            } else if (exp3.equals("*")) {
                stack.push(stack.pop() * stack.pop());
            } else if (exp3.equals("/")) {
                int exp1 = stack.pop();
                int exp2 = stack.pop();
                stack.push(exp2 / exp1);
            } else {
                stack.push(Integer.valueOf(exp3));
            }
        }
        return stack.pop().intValue();
    }
}
```





## 7.滑动窗口最大值

### 题目

[力扣题目链接](https://leetcode.cn/problems/sliding-window-maximum/)

给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值。

进阶：

你能在线性时间复杂度内解决此题吗？

![img](./pictures/239.滑动窗口最大值.png)

提示：

- 1 <= nums.length <= 10^5
- -10^4 <= nums[i] <= 10^4
- 1 <= k <= nums.length

### 思路

这题是单调队列的经典题目

```
思路：
使用单调队列来记录滑动窗口中可能的最大值
维护一个单调递减的单调队列，用来存放滑动窗口中的元素
比如如果滑动窗口元素为[3,2,4],那么单调队列中存放的就是[4]
如果滑动窗口元素为[7,3,5],那么单调队列中存放的就是[7,5]
将滑动窗口中的元素存入单调队列时是按如下规则来的：
1.首先初始化单调队列，也就是滑动窗口还没开始移动的时候
遍历滑动窗口中的元素，如果当前元素大于单调队列的第一个元素，直接清空队列并将当前元素存入队列
如果当前元素小于单调队列的最后一个元素，直接将当前元素存入队列末尾
如果当前元素小于队列第一个元素，但是大于队列最后一个元素，则将队列末尾元素弹出，直到队列末尾元素大于当前元素，就将当前元素存入队列末尾
以上所有情况可以直接总结为：如果当前元素大于队尾元素，就弹出队尾元素，直到队尾元素大于或等于当前元素，即满足单调性时。

 2.初始化完成后，滑动窗口开始移动，此时滑动窗口就是移除一个元素的添加一个新元素
 如果移除的元素等于队列的第一个元素，则将队列第一个元素弹出，否则不用管
 如果添加的元素大于队列的第一个元素，则清空队列，并将添加的元素存入队列
 如果添加的元素小于队列的第一个元素，但是大于队列的最后一个元素，则将队列末尾元素弹出，直到队列末尾元素大于当前元素，就将新元素存入队列末尾
 以上所有情况可以直接总结为：如果当前元素大于队尾元素，就弹出队尾元素，直到队尾元素大于或等于当前元素，即满足单调性时。
 要获取当前窗口的最大元素时，直接取出当前队列的第一个元素即可
```



```java
//239.滑动窗口最大值
public class LeetCode239 {

    public static void main(String[] args) {
        System.out.println(Arrays.toString(maxSlidingWindow(new int[]{1, 3, -1, -3, 5, 3, 6, 7}, 3)));
    }


    public static int[] maxSlidingWindow(int[] nums, int k) {
        //看了别人的代码自己写的，思路同样是单调队列，但是别人只用了大概20行代码就搞定了，我下面的代码却用了80多行，好好学学别人的代码是咋写的吧。。。

        //虽然同样采用的是单调队列，但是别人单调队列中存放的是数组下标，这样的好处是可以很方便地判断队列第一个元素是否在滑动窗口范围内
        Deque<Integer> deque = new ArrayDeque<>();
        int[] res = new int[nums.length - k + 1];
        //idx表示返回结果res的下标
        int idx = 0;
        for (int i = 0; i < nums.length; i++) {
            //滑动窗口范围为[i-k+1,i]
            //如果队列第一个元素不在滑动窗口范围内，就将其弹出
            while (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {
                deque.pollFirst();
            }
            //如果新增元素大于队尾元素就弹出队尾元素，直到新增元素小于队尾元素
            while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
                deque.pollLast();
            }

            //将新增元素存入单调队列（存下标）
            deque.offerLast(i);

            //每次滑动窗口，就将该窗口中的最大值存入返回结果中
            if (i >= k - 1) {
                res[idx++] = nums[deque.peekFirst()];
            }
        }

        return res;
    }


    public int[] maxSlidingWindow_My(int[] nums, int k) {
        /**
         * 思路：
         * 使用单调队列来记录滑动窗口中可能的最大值
         * 维护一个单调递减的单调队列，用来存放滑动窗口中的元素
         * 比如如果滑动窗口元素为[3,2,4],那么单调队列中存放的就是[4]
         * 如果滑动窗口元素为[7,3,5],那么单调队列中存放的就是[7,5]
         * 将滑动窗口中的元素存入单调队列时是按如下规则来的：
         * 1.首先初始化单调队列，也就是滑动窗口还没开始移动的时候
         * 遍历滑动窗口中的元素，如果当前元素大于单调队列的第一个元素，直接清空队列并将当前元素存入队列
         * 如果当前元素小于单调队列的最后一个元素，直接将当前元素存入队列末尾
         * 如果当前元素小于队列第一个元素，但是大于队列最后一个元素，则将队列末尾元素弹出，直到队列末尾元素大于当前元素，就将当前元素存入队列末尾
         * 以上所有情况可以直接总结为：如果当前元素大于队尾元素，就弹出队尾元素，直到队尾元素大于或等于当前元素，即满足单调性时。
         *
         *  2.初始化完成后，滑动窗口开始移动，此时滑动窗口就是移除一个元素的添加一个新元素
         *  如果移除的元素等于队列的第一个元素，则将队列第一个元素弹出，否则不用管
         *  如果添加的元素大于队列的第一个元素，则清空队列，并将添加的元素存入队列
         *  如果添加的元素小于队列的第一个元素，但是大于队列的最后一个元素，则将队列末尾元素弹出，直到队列末尾元素大于当前元素，就将新元素存入队列末尾
         *  以上所有情况可以直接总结为：如果当前元素大于队尾元素，就弹出队尾元素，直到队尾元素大于或等于当前元素，即满足单调性时。
         *  （所以就不要像我下面的代码那样分那么多种情况了，实际上一行代码就可以搞定，详见上面别人的代码）
         *
         *  要获取当前窗口的最大元素时，直接取出当前队列的第一个元素即可
         */

        //单调递减队列
        Deque<Integer> deque = new LinkedList<>();
        int[] result = new int[nums.length - k + 1];
        //left和right表示滑动窗口的范围
        int left = 0;
        int right = k - 1;
        //初始化队列
        for (int i = left; i <= right; i++) {
            addElement(nums[i], deque);
        }
        result[left] = deque.peekFirst();
        //开始移动滑动窗口
        left++;
        right++;
        while (right < nums.length) {
            //处理移除的元素
            if (nums[left - 1] == deque.peekFirst()) {
                //如果移除的元素为队列的第一个元素，直接弹出队列第一个元素
                deque.pollFirst();
            }
            //处理添加的元素
            addElement(nums[right], deque);
            result[left] = deque.peekFirst();
            left++;
            right++;

        }
        return result;
    }

    private static void addElement(int num, Deque<Integer> deque) {
        if (deque.isEmpty() || num > deque.peekFirst()) {
            deque.clear();
            deque.offerLast(num);
        } else if (num <= deque.peekFirst()) {
            while (deque.peekLast() < num) {
                //如果队列最后一个元素小于当前元素，则弹出最后一个元素
                deque.pollLast();
            }
            deque.offerLast(num);
        }
    }


}
```



