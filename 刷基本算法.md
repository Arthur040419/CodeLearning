# 基本算法

这篇笔记用于记录我基本算法的学习。

参考资料：[代码随想录](https://programmercarl.com/)

# 数组

## 1.二分查找

### 题目

LeetCode原题：[704. 二分查找 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-search/description/)

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

示例 1:

```text
输入: nums = [-1,0,3,5,9,12], target = 9     
输出: 4       
解释: 9 出现在 nums 中并且下标为 4     
```

示例 2:

```text
输入: nums = [-1,0,3,5,9,12], target = 2     
输出: -1        
解释: 2 不存在 nums 中因此返回 -1        
```

提示：

- 你可以假设 nums 中的所有元素是不重复的。
- n 将在 [1, 10000]之间。
- nums 的每个元素都将在 [-9999, 9999]之间。



### 思路

仅仅是一道简单的二分查找我也收获了很多。

我虽然能够把这题写出来，但是我没有一个完整的思路，属于是想到哪写到哪，这种写代码的方式很容易导致细节方面的错误，而且写的代码质量也不咋地，说实话，看起来杂乱无章。

我的代码

```java
public static int search(int[] nums, int target) {
    if(target<nums[0]||target>nums[nums.length-1]){
        //避免目标不不在数组内的时候还仍然跑到数组里去找
        return -1;
    }
    int left = 0;
    int right = nums.length - 1;
    int mid = (left + right) / 2;
    int rs = -1;
    //如果左边索引已经超过右边索引就退出循环
    while (left <= right) {
        if (nums[mid] == target) {
            rs = mid;
            break;
        } else {
            if (nums[mid] < target) {
                //说明目标值在右半部分
                left = mid + 1;
            } else {
                //说明目标值在左半部分
                right = mid - 1;
            }
        }
        mid = (left + right) / 2;
    }
    return rs;
}
```



一道简单的二分查找的思路也非常耐人寻味。因为说实话，确实如这个代码随想录这个教程所说，我在编写二分查找算法的时候经常会纠结于循环条件到底是`left<=right`,还是`left<right`，实际上这两种都对，只不过对应了两种不同的思路

思路一：

判断区间是[left,right]也就是左闭右闭，就是说判断值在在不在区间内会把两个边界值也考虑进去，这个时候我们在更改指针的时候应该这样做：当`target<nums[mid]`时，应该`right=mid-1`,当`target>nums[mid]`时，应该`left=mid+1`，并且循环条件应该是`left<=right`



思路二：

判断区间是[left,right)也就是左闭右开，也就是说判断时不会把最右边的值考虑进去，这个时候应该这样做：当`target<nums[mid]`时，应该`right=mid`，不用-1，因为判断时不会把最右边的包括进去。当`target>nums[mid]`时，应该`left=mid+1`，因为左边还是包含的，因此得加1。并且此时循环条件应该是`left<right`，因为等于的话就没有意义，反正最右边的值不会算入到判断中。





## 2.移出元素（相向双指针）

### 题目

[27. 移除元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-element/description/)

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并**原地**修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。

示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。

**你不需要考虑数组中超出新长度后面的元素。**



### 思路

这道题我一开始想到的思路是相向双指针，但是写的时候也是依托，代码思路一点也不清晰，乱糟糟的，最后调试半天才过。

通过这道题，我重新学习了相向双指针的代码到底该如何写，真的，不看看这些大佬们的代码，真不知道自己写的代码真就是依托又依托

相向双指针思路

```java
public static int removeElement_My(int[] nums, int val) {
    //相向双指针
    int left = 0;
    int right = nums.length-1;
    while (right >= 0 && nums[right] == val) right--;       //从右往左找到第一个非val值
    while (left <= right) {
        if (nums[left] == val) {
            nums[left] = nums[right];
            right--;
            //如果是我，我会在这里写个count++，完全不会去想用left指针作为返回值
            //count++
        }
        left++;
        while (right >= 0 && nums[right] == val) right--;
    }
    //直接将索引作为返回值，不像我还得拿个什么count变量来记录
    return left;
}
```



除了重新认识了相向双指针外，还学会了快慢指针思路

```java
public static int removeElement(int[] nums, int val) {
    //学到的思路，快慢指针
    int slowIndex = 0;
    for (int fastIndex = 0; fastIndex < nums.length; fastIndex++) {
        if (nums[fastIndex] != val) {
            nums[slowIndex] = nums[fastIndex];
            slowIndex++;
        }
    }
    return slowIndex;
}
```



## 3.有序数组的平方（相向双指针）

### 题目

[力扣题目链接](https://leetcode.cn/problems/squares-of-a-sorted-array/)

给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。

示例 1：

- 输入：nums = [-4,-1,0,3,10]
- 输出：[0,1,9,16,100]
- 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]

示例 2：

- 输入：nums = [-7,-3,2,3,11]
- 输出：[4,9,9,49,121]



### 思路

这题还是双指针，数组实际上是排好序的，只不过在平方后，前面的可能会比后面的大，所以可以分别用指针来指最前面和最后面，因为平方后的最大值一定是首尾两个中的一个

```java
public static int[] sortedSquares(int[] nums) {
    //相向双指针
    int left = 0;
    int right = nums.length - 1;
    int[] newArr = new int[nums.length];
    //逆向放入新数组，因为平方后最大值一定在最两边
    for (int i = newArr.length - 1; i >= 0; i--) {
        if((nums[left]*nums[left])>(nums[right]*nums[right])){
            newArr[i]=nums[left]*nums[left];
            left++;
        }else{
            newArr[i]=nums[right]*nums[right];
            right--;
        }
    }
    return newArr;
}
```





## 4.长度最小的子数组（滑动窗口）

### 题目

[力扣题目链接](https://leetcode.cn/problems/minimum-size-subarray-sum/)

给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。

示例：

- 输入：s = 7, nums = [2,3,1,2,4,3]
- 输出：2
- 解释：子数组 [4,3] 是该条件下的长度最小的子数组。

提示：

- 1 <= target <= 10^9
- 1 <= nums.length <= 10^5
- 1 <= nums[i] <= 10^5



### 思路

滑动窗口：**就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果**。

这题的思路是滑动窗口，这里窗口指的就是子数组，滑动窗口指的就是动态改变子数组的长度，那这个动态是怎么个动态法？

如果当前子数组的和小于目标值，就扩大窗口，也就是向后移动移动右边的指针，并保持左边的指针不动

如果当前子数组的和小于目标值，就缩小窗口，也就是向后移动左边的指针，并保持右边的指针不动，直到子数组的和小于目标值。

这样就能一步步找到最短的子数组，就像试探一样，先一直加加加，当加到超过目标值后就尝试慢慢减，看到底减多少会刚好小于目标值

代码如下

```java
public static int minSubArrayLen(int target, int[] nums) {
    //思路：滑动窗口
    int rs = Integer.MAX_VALUE;
    //滑动窗口前面的指针
    int fast = 0;
    //滑动窗口后面的指针
    int slow = 0;
    //子数组的和
    int sum = 0;
    for (fast = 0; fast < nums.length; fast++) {
        sum += nums[fast];
        while (sum >= target) {
            int subLength = fast - slow + 1;
            rs = rs < subLength ? rs : subLength;
            sum-=nums[slow++];
        }
    }
    if(rs==Integer.MAX_VALUE) return 0;
    return rs;
}
```







## 5.螺旋矩阵II

### 题目

[力扣题目链接](https://leetcode.cn/problems/spiral-matrix-ii/)

给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。

示例:

输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]



### 思路

这题没有涉及到算法，主要是要掌握螺旋矩阵的模拟过程。这个模拟过程看似思路侵袭，实则处处碰壁。

我自己写代码的时候就有下面这些问题：

1.当n为1的特殊情况没有处理

2.无法正确把握下一次要填数据的位置



实际上就算是模拟也讲究思路的，这题主要要抓住一个循环不变量原则，这里的不变量指的是在分别处理上行、右列、下行、左列时到底是左闭右闭还是左闭右开还是其他，这里的话个人感觉左闭右开会好写很多，也就是在处理的时候每行，每列的最后一个不处理。

然后这题还有个技巧，就是每处理完一轮上行、右列、下行、左列可以看成是处理完一圈，也就是说可以按每圈每圈来处理，只不过这个圈每次都会逐渐变小，例如如果n为4，就有两圈，最外面一圈是边长为4的正方形，里面一圈是边长为2的正方形，如果n为3，最外面一圈就是边长为3的正方形，最里面是边长为1的正方形，也就是一个点。

所以我们可以得到一个结论，n阶矩阵可以看成n/2(向下取整)个正方形嵌套而成，其中如果n为奇数的时候还要在此基础上加上一个点，也就是1阶矩阵，这个要单独处理

仿照示例代码，并做出了点修改

```java
public static int[][] generateMatrix(int n) {
    //仿示例代码
    int[][] arr = new int[n][n];
    //每次要放入的数据
    int value = 1;
    //代表行
    int row = 0;
    //代表列
    int column = 0;
    //代表圈的边长,每圈的边长等于n-（循环圈数-1）*2
    int side = n;
    //代表循环的圈数
    int loop = 1;
    while (loop <= n / 2) {
        //处理上行
        for (int i = 0; i < side - 1; i++) {
            arr[row][column++] = value++;
        }
        //处理右列
        for (int i = 0; i < side - 1; i++) {
            arr[row++][column] = value++;
        }
        //处理下行
        for (int i = 0; i < side - 1; i++) {
            arr[row][column--] = value++;
        }
        //处理左列
        for (int i = 0; i < side - 1; i++) {
            arr[row--][column] = value++;
        }
        //处理完一圈，圈数加1
        loop++;
        //边长减2
        side -= 2;
        //重设每圈的起点
        row = loop - 1;
        column = loop - 1;
    }
    //对n为奇数时单独处理
    if (n % 2 == 1) {
        arr[row][column]=n*n;
    }
    return arr;

}
```



## 6.区间和（方法:前缀和）

### 题目

[题目链接](https://kamacoder.com/problempage.php?pid=1070)

题目描述

给定一个整数数组 Array，请计算该数组在每个指定区间内元素的总和。

输入描述

第一行输入为整数数组 Array 的长度 n，接下来 n 行，每行一个整数，表示数组的元素。随后的输入为需要计算总和的区间，直至文件结束。

输出描述

输出每个指定区间内元素的总和。

输入示例

```text
5
1
2
3
4
5
0 1
1 3
```

输出示例

```text
3
9
```

数据范围：

0 < n <= 100000



### 思路

最容易想到的就是暴力求解，直接先输入数组，在遍历数组取区间和。但是老是用这种暴力解法是没有办法进步的，暴力解法谁都能想到

这题要用的新思路是：前缀和。前缀和的思想是重复利用计算过的子数组之和，从而降低区间查询的次数。

在输入原数组的时候，就可以创建一个前缀和数组p[]来一步一步记录前缀和，p[i]代表的就是前i个元素的和，最终当数组输入完毕后，前缀和数组也就记录完毕。此时如果我们想要计算某个区间的和，例如计算a、b区间的和，只需要用前缀和p[b]减去前缀和p[a-1]，这里要注意的就是减的时候应该是减p[a-1]而不是p[a]，因为a、b区间的和包括a这个位置的元素。这样做，在每次计算区间和的时候就只用计算一次，不需要像暴力解法那样去重复查找原数组。

代码如下

```java
public static void subArrSum() {
    //前缀和
    Scanner sc = new Scanner(System.in);
    int n = sc.nextInt();
    //前缀和数组，p[i]表示arr[0]~arr[i]的和
    int[] p = new int[n];
    //初始化数组
    p[0] = sc.nextInt();
    for (int i = 1; i < n; i++) {
        int num = sc.nextInt();
        p[i] = p[i - 1] + num;
    }
    int a;
    int b;
    //这里循环条件注意别用true，用sc.hasNext这些
    while(sc.hasNextInt()){
        //输入区间
        a=sc.nextInt();
        b=sc.nextInt();
        if(a==0){
            //对左边界为0的时候特殊处理
            System.out.println(p[b]);
        }else {
            System.out.println(p[b] - p[a - 1]);
        }
    }
    sc.close();

}
```





## 7.开发商购买土地

### 题目

[题目链接](https://kamacoder.com/problempage.php?pid=1044)

【题目描述】

在一个城市区域内，被划分成了n * m个连续的区块，每个区块都拥有不同的权值，代表着其土地价值。目前，有两家开发公司，A 公司和 B 公司，希望购买这个城市区域的土地。

现在，需要将这个城市区域的所有区块分配给 A 公司和 B 公司。

然而，由于城市规划的限制，只允许将区域按横向或纵向划分成两个子区域，而且每个子区域都必须包含一个或多个区块。

为了确保公平竞争，你需要找到一种分配方式，使得 A 公司和 B 公司各自的子区域内的土地总价值之差最小。

注意：区块不可再分。

【输入描述】

第一行输入两个正整数，代表 n 和 m。

接下来的 n 行，每行输出 m 个正整数。

输出描述

请输出一个整数，代表两个子区域内土地总价值之间的最小差距。

【输入示例】

3 3 1 2 3 2 1 3 1 2 3

【输出示例】

0

【提示信息】

如果将区域按照如下方式划分：

1 2 | 3 2 1 | 3 1 2 | 3

两个子区域内土地总价值之间的最小差距可以达到 0。

【数据范围】：

- 1 <= n, m <= 100；
- n 和 m 不同时为 1。

![image-20250308235348389](./pictures/image-20250308235348389.png)



### 思路

还好这题只要求横向划分和纵向划分，如果来个斜向划分就麻烦了。

横向划分，可以看成是由前几行组成一块区域，最后几行组成一块区域，而每块区域的权值和不就是对应那几行的数据加起来吗，然后我们可以把每一行数据先加起来看成一个值，假如说第一块区域由前3行组成，那么第一块区域的权值和就是第一行的权值和加上第二行的权值和再加上第三行的权值和，这样一来一个二位数组其实就可以看成是一维数组，一维数组的每个值对应的就是二维数组每一行的权值和，这样一来这个开发商问题就转化成了将一维数组划分为两个子数组，然后求两个子数组的最小差值的问题。

纵向划分也是同理。

问题一转化思路就清晰了，用前缀和就非常好求。假如我们的到一个横向划分的前缀和数组row[3]，row[0]代表前一行的权值和，row[1]代表前2行的权值和.....，此时我们就可以遍历所有划分情况，然后计算每一种划分情况的两块区域差值，比如以第一行为一个区域，剩下两行为另一个区域，那么这两区域的差值就是row[2]-row[0]*2，首先row[2]-row[0]就是第二个区域的权值和，再减去row[0]才是两个区域的差值。

要注意的是计算差值一定要关注需不需要求结果的绝对值，这题显然是要的。

代码如下

```java
import java.util.Scanner;

//开发商购买土地
public class KamaCoder44 {
    public static void main(String[] args) {
        buyLand();
    }

    public static void buyLand() {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int[][] lands = new int[n][m];
        //min表示两块区域土地的最小权值差
        int min = Integer.MAX_VALUE;
        //输入土地的权值，并顺便统计横向土地权值和以及纵向土地权值和
        //row[i]表示第i行的所有土地的权值和
        int[] row = new int[n];
        //column[j]表示第j列的所有土地权值和
        int[] column = new int[m];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                lands[i][j] = sc.nextInt();
                row[i] += lands[i][j];
                column[j] += lands[i][j];
            }
        }

        //计算横向前缀和，preRow[i]表示前i行的所有土地权值和
        int[] preRow = new int[n];
        preRow[0] = row[0];
        for (int i = 1; i < row.length; i++) {
            preRow[i] = preRow[i - 1] + row[i];
        }

        //计算纵向前缀和，preColumn[j]表示前j列的所有土地的权值和
        int[] preColumn = new int[m];
        preColumn[0] = column[0];
        for (int i = 1; i < column.length; i++) {
            preColumn[i] = preColumn[i - 1] + column[i];
        }

        //横向划分
        for (int i = 1; i < preRow.length; i++) {
            int dif = Math.abs(preRow[preRow.length - 1] - preRow[i - 1]*2);
            min = dif < min ? dif : min;
        }

        //纵向划分
        for (int i = 1; i < preColumn.length; i++) {
            int dif = Math.abs(preColumn[preColumn.length - 1] - preColumn[i - 1]*2);
            min = dif < min ? dif : min;
        }
        System.out.println(min);

    }
}
```





# 链表

## 1.链表理论基础

### 链表节点的定义

```java
public class ListNode {
    //节点的值
    int val;

    //下一个节点的地址
    ListNode next;

    public ListNode() {
    }

    public ListNode(int val) {
        this.val = val;
    }

    //这个好像不大需要
//    public ListNode(ListNode next) {
//        this.next = next;
//    }

    public ListNode(int val, ListNode next) {
        this.val = val;
        this.next = next;
    }
}
```





## 2.移出链表元素

### 题目

[力扣题目链接](https://leetcode.cn/problems/remove-linked-list-elements/)

题意：删除链表中等于给定值 val 的所有节点。

示例 1： 输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5]

示例 2： 输入：head = [], val = 1 输出：[]

示例 3： 输入：head = [7,7,7,7], val = 7 输出：[]



### 思路

删除链表元素的思路没什么好讲的，就是遍历然后判断要不要删。

主要要知道的是涉及链表元素操作的两种方式：

1.直接使用原来的链表进行操作

这种方式在删除节点的时候是通过要删除节点前面那个节点来删除的，但是头节点前面没有节点，因此要单独处理头节点。

头节点的处理也很简单，当判断头节点符合被删除的要求时，只需要将头节点往前移，这样就相当于删除了原来的头节点。



2.设置一个虚拟头节点再进行操作

这种方式的好处在于删除头节点的操作方式与删除其他节点的方式一样了，因此不用单独处理头节点



这题我用的是第二种方式，代码如下，我一开始写的代码不是下面这样的，写的很烂，所以好好学一学下面的代码吧。

```java
public static ListNode removeElements(ListNode head, int val) {
    //参考的别人的代码
    ListNode dummyNode = new ListNode();
    dummyNode.next = head;
    //创建一个当前节点
    ListNode currentNode = dummyNode;
    while(currentNode.next!=null){
        if(currentNode.next.val==val){
            currentNode.next=currentNode.next.next;
        }else {
            currentNode=currentNode.next;
        }
    }
    return dummyNode.next;
}
```



## 3.设计链表

### 题目

[力扣题目链接](https://leetcode.cn/problems/design-linked-list/)

题意：

在链表类中实现这些功能：

- get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。
- addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。
- addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。
- addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。
- deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。

![707示例](./pictures/20200814200558953.png)

### 思路

这道题模拟了链表的几个操作，用来熟悉练习链表非常不错。

做这道题我出现的问题主要是自己对链表这一数据结构没有一个标准的概念，我知道什么是链表，也直到链表怎么实现，但是实现链表的方式不止一种，在写这个代码的时候，我脑袋里一会儿想这这种实现方式，一会儿有想到了那种实现方式，导致整个过程非常混乱，思路不清晰。

所以我觉得做这种题，首先就要先明确自己到底要用那种方式，例如要先弄清楚size代表什么，是当前链表最大索引还是当前链表长度，再如链表要不要虚拟头节点。把这些基本的东西搞清除，制定一个规范再下笔，思路才会更清晰。

代码如下

```java
//设计链表
public class LeetCode707 {

}


/**
 * 在模拟链表这种数据结构的时候最好能有一个统一的规定，例如要先弄清楚size代表什么，是当前链表最大索引还是当前链表长度，再如链表要不要虚拟头节点。
 * 有一个统一的规定模拟起来才不会混乱，再下次遇到的时候心里也有一个整体的规范，不然脑袋里面就会变来变去，非常影响编写代码
 * 这里我就做一个统一的规范，以后遇到链表相关的模拟就按这个规范来
 * 1.采用单链表，一个节点只包含val和next
 * 2.采用虚拟头节点
 * 3.size代表链表的实际长度
 */
class MyLinkedList {
    class ListNode {
        int val;
        ListNode next;

        ListNode() {
        }

        ListNode(int val, ListNode next) {
            this.val = val;
            this.next = next;
        }
    }

    //链表的虚拟头节点
    ListNode head;
    //链表的实际长度
    int size;

    public MyLinkedList() {
        //初始化链表
        head = new ListNode();
        size = 0;
    }

    public int get(int index) {
        //获取指定索引的节点
        //首先处理非法索引
        if(index<0||index>=size){
            return -1;
        }
        //当前节点
        ListNode cur = head;
        for (int i = 0; i <= index; i++) {
            cur=cur.next;
        }
        return cur.val;
    }

    public void addAtHead(int val) {
        //在头节点前面添加元素
        //让新节点的next指向原来的头节点
        ListNode newNode = new ListNode(val,head.next);
        //只需让虚拟头节点指向要添加的节点即可
        head.next = newNode;
        //别忘了让链表的长度+1
        size++;
    }

    public void addAtTail(int val) {
        //在尾节点后面添加元素
        ListNode cur = head;
        //先遍历节点，一直到尾节点
        while(cur.next!=null){
            cur=cur.next;
        }
        //创建一个新节点并让旧尾节点指向新尾节点
        ListNode newNode = new ListNode(val,null);
        cur.next=newNode;
        //别忘了让链表长度+1
        size++;
    }

    public void addAtIndex(int index, int val) {
        //在指定索引位置添加元素
        //首先处理非法索引，在这里索引为size的情况并不是非法情况，如果索引为size，说明新节点是插入到链表尾部的
        if(index<0||index>size){
            return;
        }
        //遍历链表，直到目标索引的前驱节点
        ListNode cur = head;
        for (int i = 0; i < index; i++) {
            cur=cur.next;
        }
        //新建要插入的节点，并让新节点指向原来在这个索引位置的节点
        ListNode newNode = new ListNode(val,cur.next);
        //让前驱节点指向新节点
        cur.next=newNode;
        //别忘了让链表长度+1
        size++;
    }

    public void deleteAtIndex(int index) {
        //删除指定索引的节点
        //处理非法索引
        if(index<0||index>=size){
            return;
        }
        ListNode cur = head;
        //遍历到要删除节点的前驱节点
        for (int i = 0; i < index; i++) {
            cur=cur.next;
        }
        //直接让前驱节点指向被删除节点的下一个节点即可
        cur.next=cur.next.next;
        //别忘了让链表长度-1
        size--;
    }
}
```





## 4.翻转链表

### 题目

[力扣题目链接](https://leetcode.cn/problems/reverse-linked-list/)

题意：反转一个单链表。

示例: 输入: 1->2->3->4->5->NULL 输出: 5->4->3->2->1->NULL



### 思路

采用双指针法。定义一个cur指针代表当前节点，定义一个pre代表前驱节点，定义一个tmp代表临时节点，临时节点用于保存下一个节点的位置。

翻转时，只需将cur的next指向pre即可，完成翻转后cur和pre都向前移动一个节点直到翻转完所有节点

代码如下

```java
//反转链表
public class LeetCode206 {

}
class Solution {
    public ListNode reverseList(ListNode head) {
        //双指针法
        //当前节点
        ListNode cur = head;
        //前驱节点
        ListNode pre = null;
        //临时节点
        ListNode tmp = null;
        while(cur!=null){
            //保存下一个节点的位置
            tmp=cur.next;
            cur.next=pre;
            //两个指针都向前移动一个节点
            pre=cur;
            cur=tmp;
        }
        return pre;
    }
}

//LeetCode题目给的链表节点类，不是我自己定义的
class ListNode {
      int val;
      ListNode next;
      ListNode() {}
      ListNode(int val) { this.val = val; }
      ListNode(int val, ListNode next) { this.val = val; this.next = next; }
  }
```