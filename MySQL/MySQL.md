# MySQL

MySQL的基础操作已经在JavaWeb中学了，这里就不在赘述



## 事务

### 并发事务问题

#### 1.脏读

一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。





## 存储引擎

#### MySQL体系结构

![image-20250507154935243](./pictures/image-20250507154935243.png)



#### 什么是存储引擎

 存储引擎是存储数据、建立索引、更新查询表等操作的实现方式。存储引擎是基于表来的，每一个表所使用的存储引擎可以不一样，因此存储引擎也被称为表类型。

在创建表的时候可以指定存储引擎：

![image-20250507155436512](./pictures/image-20250507155436512.png)

如果不指定存储引擎，默认使用InnoDB

可以查看当前MySQL支持的存储引擎：

```mysql
show engines
```





#### InnoDB介绍

#####  InnoDB的特点

1.对数据的增删改查（DML）操作遵循ACID原则，支持事务

2.支持行级锁，提高并发访问性能

3.支持外键，可以保证数据的完整性和一致性



每一个使用InnonDB引擎的表都会有一个对应的`xxx.ibd`文件，该文件包括了表的结构、表的数据、索引。



##### InnoDB的逻辑存储结构

![image-20250507160426442](./pictures/image-20250507160426442.png)

每一个区的大小固定为1M，包含多个页

每一个页的大小固定为16K，包含多个行，每一行对应的就是每一条记录





#### MyISAM介绍

MyISAM是MySQL早期的默认存储引擎。

特点：

1.不支持事务，不支持外键

2.支持表级锁，不支持行级锁

3.访问速度快



文件结构：

使用MyISAM的表会产生3个文件：

1.`xxx.MYD`，保存了表的数据

2.`xxx.MYI`，保存了表的索引

3.`xxx.sdi`，保存了表的结构



#### Memory介绍

Memory引擎的表的数据是存放在内存中的，因此只适合用来作为临时表或缓存使用

特点：

1.数据存储在内存中，访问速度快

2.默认使用hash索引



文件结构：

使用Memory引擎的表只有一个`xxx.sdi`文件用于存储表结构



#### 三个存储引擎的对比

![image-20250507161314649](./pictures/image-20250507161314649.png)





## 索引

### 索引介绍

索引是一种帮助MySQL快速查询数据的数据结构。

索引的优缺点如下：

![image-20250507162623773](./pictures/image-20250507162623773.png)





### 索引结构简述

常见的索引有如下几种：

![image-20250507162926670](./pictures/image-20250507162926670.png)

由于索引是在数据引擎层实现的，因此不同的引擎所支持的索引结构也不一样：

![image-20250507163016469](./pictures/image-20250507163016469.png)



### BTree

#### 使用二叉树实现索引的缺点

1.当顺序存储数据时，二叉树索引就会形成一个链表。

2.二叉树的每个节点只有两个子节点，当数据量较大时，层级较深，检索速度慢。

![image-20250507163518128](./pictures/image-20250507163518128.png)

红黑树虽然解决了第一个缺点，但是第二个缺点仍然存在





#### BTree的构建过程

BTree是多路平衡搜索树。

BTree涉及到一个概念：树的度数

树的度数指的是一个节点的最大子节点个数。

![image-20250507164327669](./pictures/image-20250507164327669.png)

对于度数为5的树，其每一个节点最多存储4个数据，因为需要5个指针指向子节点，而指针树就是每个几点的数据个数+1。

当一个节点存储的数据个数等于度数时，该节点的中间数值会向上分裂，如下图所示：

下图展示的是一个度数为4的BTree，依次插入下面数据时，树的构建过程

**6 10 4 14 5 11 15 3 2 12 1 7 8 8 6 3 6 21 5 15 15 6 32 23 45 65 7 8 6 5 4**

![img](./pictures/89f1cb27d14ebbd147cfa87fb5d10ea7.gif)





### B+Tree

#### B+Tree的特点

1.所有的数据都会出现在叶子节点

2.非叶子节点起到索引的作用，不存放数据（对比BTree的不同）

3.所有叶子节点之间形成一个单向链表（MySQL实际使用中对此进行了一定优化）。

![image-20250507165347229](./pictures/image-20250507165347229.png)



#### B+Tree的构建过程

以一个度数为4的B+Tree为例，依次插入以下数据：

**6 10 4 14 5 11 15 3 2 12 1 7 8 8 6 3 6 21 5 15 15 6 32 23 45 65 7 8 6 5 4**

![img](./pictures/4c27b7e3bb7440019f3cc9d032cb122e.gif)



#### MySQL中的B+Tree结构

MySQL在原本的B+Tree基础上进行了优化：

![image-20250507165608919](./pictures/image-20250507165608919.png)



#### MySQL中采用B+Tree而不采用BTree的原因

1.BTree每个节点都要存放数据，而节点又是放在页中存储的，页的空间大小是固定的，因此BTree在一个节点中能存放的键值是小于B+Tree的，也就导致了BTree单个节点的指针数量会减少，此时如果要保存大量数据，BTree就只能增加树的高度，导致性能降低。

2.B+Tree的所有数据都在叶子节点，查询性能稳定

3.B+Tree结构中，所有叶子节点之间采用双向链表连接，方便排序和范围查找





#### 不同高度的B+Tree存储的数据量为多少

B+Tree的每一个节点是存放在页中的，而每一页的大小固定为16k，那么就会有如下计算方法：

![image-20250508081657812](./pictures/image-20250508081657812.png)



可以看到高度为3的B+Tree就可以存储2千万条数据。







###  Hash索引

#### Hash索引的特点

1.只支持等值匹配，不支持范围查询

2.无法利用索引完成排序操作

3.查询效率高，通常只需要一次检索就能找到数据。





#### Hash索引的构建过程

![image-20250507170644010](./pictures/image-20250507170644010.png)





### 索引分类

#### MySQL下的索引分类

MySQL有以下四种类型的索引：

![image-20250507173249452](./pictures/image-20250507173249452.png)



#### InnoDB下的索引分类

在InnoDB引擎下，根据索引的存储形式，又将索引分为以下两种：

1.聚集索引

2.二级索引

![image-20250507173353554](./pictures/image-20250507173353554.png)



下面是聚集索引和二级索引具体的实现情况：

![image-20250507173436567](./pictures/image-20250507173436567.png)

当通过name字段查询是，首先就会查询name字段的二级索引，比如要查询name=Arm的数据，就会先从二级索引中找到该记录的主键id值为10，接着再用主键id值去聚集索引里面找该条记录的真正数据。

根据从二级索引找到的主键id去聚集索引里面寻找这一过程称为回表查询。





### 索引相关语法

![image-20250508081913698](./pictures/image-20250508081913698.png)

如果索引关联一个字段，就称这个索引为单列索引；如果索引关联多个字段，就称这个索引为联合索引、组合索引。



### 性能分析

#### 查看数据库各种操作执行的频率

![image-20250508082952849](./pictures/image-20250508082952849.png)

查询结果如下：

![image-20250508083014115](./pictures/image-20250508083014115.png)

可以看到各个操作的的执行次数，其中select操作执行次数最多。



#### 慢查询日志

慢查询日志里面记录了所有执行时间超过指定时间（默认为10s）的SQL语句。

![image-20250508083745949](./pictures/image-20250508083745949.png)

可使用以下命令查看慢查询日志是否开启

```mysql
show variables like 'slow_query_log'
```





#### profile详情

profile中记录了所有SQL语句的执行耗时（不管执行时间是多少），并且通过query_id可以查看对应语句各个阶段的耗时。

![image-20250508084513727](./pictures/image-20250508084513727.png)

具体使用命令：

![image-20250508084540098](./pictures/image-20250508084540098.png)





#### explain执行计划

![image-20250508091448006](./pictures/image-20250508091448006.png)

示例如下：

![image-20250508091541345](./pictures/image-20250508091541345.png)

![image-20250508091606139](./pictures/image-20250508091606139.png)

![image-20250508091626473](./pictures/image-20250508091626473.png)





### 索引的使用

#### 最左前缀法则

对于联合索引，查询从索引的最左列开始，并且不跳过索引中的列，如果跳过了某一列，那么后续的索引将会失效。

假如有一个联合索引，其字段依次为：profession、age、status

![image-20250508093153638](./pictures/image-20250508093153638.png)

对于上面几个查询命令的索引使用情况为：

1.三个字段的索引均成功使用

2.只使用了profession和age索引

3.只使用了profession索引

4.没有使用任何索引，因为最前面的profession索引没有使用，会导致后面的索引全部失效

5.没有使用任何索引，因为前面的profession和age索引都没有使用



#### 联合索引的范围查询

![image-20250508093544438](./pictures/image-20250508093544438.png)

如上图所示

对于第一个查询，只使用了前面的profession和age索引，后面的status索引失效

对于第二个查询，虽然使用了范围查询，但是存在等号，后续的索引不会失效。



#### 指定要使用的索引

当存在多个索引时，可以通过SQL语句选择忽略或指定索引，如下：

![image-20250508163706041](./pictures/image-20250508163706041.png)

第一个是建议使用某个索引，MySQL会先评估该索引是否高效，再决定要不要使用

第二个是获取某个索引

第三个是强制使用某个索引。



#### 覆盖索引

在使用索引进行查询时，尽量不要使用`select *`，而是具体指定索引包含的字段，这样查询性能会更高

![image-20250508164829974](./pictures/image-20250508164829974.png)

比如上面的示例：

第一条命令，`select *`包含了表的全部字段，由于使用的是聚集索引，聚集索引里面就包含了所有字段，因此它的查询性能较高

第二条命令，id和name字段都被包含在右边的二级索引中，其查询性能也不错

第三条命令，由于gender字段不被包含在二级索引中，因此通过二级索引查询到id后还需要回表查询，性能较低。











### 索引失效情况

以下几种情况会导致索引失效：

1.对索引列进行运算操作，索引就会失效

2.索引列是字符串类型数据，但在查询时没有用引号包裹字符串

3.模糊查询。如果仅仅是尾部的模糊匹配，索引不会失效，但是如果存在头部的模糊匹配，索引就会失效。

4.查询条件中使用 OR，且 OR 的前后条件中有一个列没有索引，涉及的索引都不会被使用到；

5.数据分布影响，如果MySQL评估使用索引比全表更慢，则不会使用索引。



下面是后续补充：

6.创建了组合索引，但查询条件未遵守最左匹配原则；



### 前缀索引

![image-20250508170011527](./pictures/image-20250508170011527.png)



 

### 联合索引

如果查询语句涉及到较多的条件查询，推荐使用联合索引，联合索引可以减少回表查询的次数

联合索引的结构如下：

![image-20250508170919299](./pictures/image-20250508170919299.png)

优先使用第一个字段排序，如果第一个字段相同，再使用后面的字段排序。







### 索引设计原则

 ![image-20250508171357682](./pictures/image-20250508171357682.png)









## SQL优化

### 插入数据

插入数据可以从以下几个方面来优化：

1.批量插入

2.手动提交事务，MySQL默认执行完一条语句就提交事务，如果有多条语句，频繁的提交事务会导致性能下降

3.按主键顺序插入数据

![image-20250508173254930](./pictures/image-20250508173254930.png)

如果要插入大量数据，比如数据量达到百万级别，使用insert就会非常耗时，推荐使用load，通过加载本地文件的方式插入数据

![image-20250508173355735](./pictures/image-20250508173355735.png)

需要注意，文件中的数据顺序也最好是按主键顺序来的。



### 主键优化

#### 1.主键设计原则

主键的设计有如下几个原则：

![image-20250508174859602](./pictures/image-20250508174859602.png)

第一点：主键长度过长，会导致索引占用空间过大，磁盘IO资源消耗也会更多，数据检索时间变长

第二点：不按顺序插入可能会造成页分裂（下面有具体介绍）

第三点：UUID或身份证号等是无序的，并且长度也不短，因此不适合作为主键





#### 2.页分裂

假如现在插入一个主键id为50的新数据，但此时索引结构如下：

![image-20250508175412767](./pictures/image-20250508175412767.png)

可以发现，此时新数据应该放在47后面，但是47所在的页所剩空间已经无法容纳新数据了，此时就会发生页分裂，第一页的数据会分为两半，后半部分会放在新的页中，并且要对页重新排序，完成页分裂后，再将新数据插入合适的位置。这个过程是非常消耗性能的。

如下图所示，page3是新建的页，原本第二页应该是page2，但是重排序后，第二页变成了page3.

![image-20250508175711817](./pictures/image-20250508175711817.png)



#### 3.页合并

在执行删除操作时，InnoDB并不会立即删除该数据，而是对该数据进行标记，标记该数据所占的内存空间为可用状态，当某一页中被删除的内存达到一定值时，InnoDB会寻找该页相邻的页，判断是否能合并成一个页，以优化空间。

下面是页合并前：

![image-20250508180120146](./pictures/image-20250508180120146.png)

合并后：

此时插入的新数据20就会按顺序存放

![image-20250508180212497](./pictures/image-20250508180212497.png)





### 排序优化（order by）

当要对查询结果进行排序时，其执行有两种情况：

![image-20250510111224419](./pictures/image-20250510111224419.png)

在执行需要排序的查询操作时，尽量选择Using index。

从以下几个方面来优化order by 查询：

1.根据字段排序建立合适的索引

比如：如果根据age升序排序，就建立一个age的升序索引。如果根据age升序排序同时根据手机号phone降序排序，则可以建立一个根据age升序，phone降序的索引。

![image-20250510111637741](./pictures/image-20250510111637741.png)



2.尽量使用覆盖索引

3.如果不可避免的出现filesort，且要排序的数据量较大时，可以适当增加排序缓冲区的大小（默认为256K）





### 分组优化（group by）

分组优化也可以像排序优化一样建立合适的索引，其索引的使用也是满足最左前缀法则的。







### 分页查询优化（limit）

分页查询查询的记录越往后，消耗的时间越长。

![image-20250510113547940](./pictures/image-20250510113547940.png)

图中的select id from ...就使用了覆盖索引。

通过覆盖索引查出所有分页数据的id，然后用id再去查找具体数据。







### count优化

对于count操作，不同的存储引擎使用的方式不同：

![image-20250510114411140](./pictures/image-20250510114411140.png)

而对于InnoDB引擎的优化，可以从count的使用方法上入手：

count的使用有这么几种方式：

1.count *  2.count (主键)  3.count(字段)  4.count(1)

它们的具体执行流程如下：

![image-20250510114553613](./pictures/image-20250510114553613.png)

因此，尽量使用耗时比较低的count就可以对count操作进行一定程度的优化。





### 更新优化（update）

更新操作的优化主要是要避免行级锁升级为表级锁。

InnoDB的行级锁是针对索引加的锁，而不是针对记录加的锁。

比如某个表tb的有两个字段：id（主键）,name

此时如果执行以下命令

```mysql
update tb set name = 'Arthur' where name = 'Sky'
```

就会出现表级锁，在这个命令的修改结果提交之前，整个表都会被锁住

但是如果执行以下命令

```mysql
update tb set name = 'Arthur' where id = 1
```

此时只有id为1的那一行记录被锁住，其他记录仍然可以被修改。

如果想解决用name字段作为条件会升级成表级锁这个问题，可以对name字段创建一个索引，这样就可以解决问题。









## 视图

### 什么是视图

视图是一张虚拟存在的表，视图中的数据是根据创建视图时所用的select语句动态生成的。

视图创建好后就可以像普通的表那样使用



### 视图的基本语法

![image-20250510125552324](./pictures/image-20250510125552324.png)





### 视图检查选项

看上面的创建视图用的SQL语句，可以看到后面有可选项：with casaded/local check option

如果不添加这个选项，那么向视图中插入新数据时，不管这个数据符不符合要求都能够插入，但是这个新数据是查询不到的。

如果添加了这个选项，插入视图时，会先检查这个新数据是否符合要求，如果符合要求才允许插入。



而添加这个可选项也有两种选择：

#### 1.cascaded

cascaded类型的检查选项，在检查时，会先检查是否符合自己视图的要求，然后再去检查是否符合本视图依赖的视图的要求，如果都满足才会允许添加新数据。

例如下图中的三个语句，最后一个语句由于没有开启视图检查，所以不会判断是否符合v3，但是会判断是否符合v3依赖的v2的要求（也就是id是否>=10），接着由于v2使用的是cascaded类型的检查选项，所以还会接着检查是否符合v2依赖的v1的要求（也就是id是否<=20）。

![image-20250510213358708](./pictures/image-20250510213358708.png)





#### 2.local

使用local类型的检查选项时，会先检查插入数据是否符合本视图的规则，然后去看本视图依赖的视图是否有设置检查选项，如果设置了检查选项才会去检查数据是否符合依赖视图的要求。

比如下面这个例子：

向v3插入数据时，由于v3没有设置检查选项，因此不会检查是否符合v3的要求，但是会检查是否符合v3依赖的v2的要求，接着由于v2使用的是local类型的检查选项，所以按理来说会去判断是否符合v2依赖的v1的要求，但是由于v1没有设置检查选项，因此不会判断是否符合v1的要求

![image-20250510214654583](./pictures/image-20250510214654583.png)

 

### 视图的更新条件

如果想要通过视图来更新数据，需要符合以下条件：

![image-20250510215338833](./pictures/image-20250510215338833.png)

### 视图的作用

在学到这里之前，我确实挺疑惑视图到底有啥用，为什么还要通过视图来修改数据，不能直接修改到表上吗？

学到这里我才恍然大悟：

补充讲解：

1.简单

例如：有一个商品表，它里面有各种字段：名称、id、价格、类型、销量、等等。。。

但是，假如只有销量经常变化，需要经常修改或查询的也就是销量，通过定义视图，只将必要的字段如：id、销量放在视图中，这样用户就能方便地进行操作，不需要关系其他无关的字段

再比如可以将涉及到多表的查询字段定义在一个视图中，这样就不需要每次都多表查询了，只需要查询视图即可。

2.数据独立

假如此时商品表的字段名发生了变化，商品名字段从原来的name变成了shopName

此时只需这样定义视图

```mysql
create or replace view v1 as select id shopName as name from shopItem
```

这样不管商品字段是shopName还是shoppingName，在用户看来永远都是name

![image-20250510215641983](./pictures/image-20250510215641983.png)













